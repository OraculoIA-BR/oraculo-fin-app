{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/victo/OneDrive/Desktop/oraculo-fin-app/node_modules/jsonata/jsonata.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.jsonata = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n * © Copyright IBM Corp. 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nconst utils = require('./utils');\n\n/**\n * DateTime formatting and parsing functions\n * Implements the xpath-functions format-date-time specification\n * @type {{formatInteger, formatDateTime, parseInteger, parseDateTime}}\n */\nconst dateTime = (function () {\n    'use strict';\n\n    const stringToArray = utils.stringToArray;\n\n    const few = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten',\n        'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'];\n    const ordinals = ['Zeroth', 'First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth',\n        'Eleventh', 'Twelfth', 'Thirteenth', 'Fourteenth', 'Fifteenth', 'Sixteenth', 'Seventeenth', 'Eighteenth', 'Nineteenth'];\n    const decades = ['Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety', 'Hundred'];\n    const magnitudes = ['Thousand', 'Million', 'Billion', 'Trillion'];\n\n    /**\n     * converts a number into english words\n     * @param {string} value - the value to format\n     * @param {boolean} ordinal - ordinal or cardinal form\n     * @returns {string} - representation in words\n     */\n    function numberToWords(value, ordinal) {\n        var lookup = function (num, prev, ord) {\n            var words = '';\n            if (num <= 19) {\n                words = (prev ? ' and ' : '') + (ord ? ordinals[num] : few[num]);\n            } else if (num < 100) {\n                const tens = Math.floor(num / 10);\n                const remainder = num % 10;\n                words = (prev ? ' and ' : '') + decades[tens - 2];\n                if (remainder > 0) {\n                    words += '-' + lookup(remainder, false, ord);\n                } else if (ord) {\n                    words = words.substring(0, words.length - 1) + 'ieth';\n                }\n            } else if (num < 1000) {\n                const hundreds = Math.floor(num / 100);\n                const remainder = num % 100;\n                words = (prev ? ', ' : '') + few[hundreds] + ' Hundred';\n                if (remainder > 0) {\n                    words += lookup(remainder, true, ord);\n                } else if (ord) {\n                    words += 'th';\n                }\n            } else {\n                var mag = Math.floor(Math.log10(num) / 3);\n                if (mag > magnitudes.length) {\n                    mag = magnitudes.length; // the largest word\n                }\n                const factor = Math.pow(10, mag * 3);\n                const mant = Math.floor(num / factor);\n                const remainder = num - mant * factor;\n                words = (prev ? ', ' : '') + lookup(mant, false, false) + ' ' + magnitudes[mag - 1];\n                if (remainder > 0) {\n                    words += lookup(remainder, true, ord);\n                } else if (ord) {\n                    words += 'th';\n                }\n            }\n            return words;\n        };\n\n        var words = lookup(value, false, ordinal);\n        return words;\n    }\n\n    const wordValues = {};\n    few.forEach(function (word, index) {\n        wordValues[word.toLowerCase()] = index;\n    });\n    ordinals.forEach(function (word, index) {\n        wordValues[word.toLowerCase()] = index;\n    });\n    decades.forEach(function (word, index) {\n        const lword = word.toLowerCase();\n        wordValues[lword] = (index + 2) * 10;\n        wordValues[lword.substring(0, word.length - 1) + 'ieth'] = wordValues[lword];\n    });\n    wordValues.hundredth = 100;\n    magnitudes.forEach(function (word, index) {\n        const lword = word.toLowerCase();\n        const val = Math.pow(10, (index + 1) * 3);\n        wordValues[lword] = val;\n        wordValues[lword + 'th'] = val;\n    });\n\n    /**\n     * Converts a number in english words to numeric value\n     * @param {string} text - the number in words\n     * @returns {number} - the numeric value\n     */\n    function wordsToNumber(text) {\n        const parts = text.split(/,\\s|\\sand\\s|[\\s\\\\-]/);\n        const values = parts.map(part => wordValues[part]);\n        let segs = [0];\n        values.forEach(value => {\n            if (value < 100) {\n                let top = segs.pop();\n                if (top >= 1000) {\n                    segs.push(top);\n                    top = 0;\n                }\n                segs.push(top + value);\n            } else {\n                segs.push(segs.pop() * value);\n            }\n        });\n        const result = segs.reduce((a, b) => a + b, 0);\n        return result;\n    }\n\n    const romanNumerals = [\n        [1000, 'm'],\n        [900, 'cm'],\n        [500, 'd'],\n        [400, 'cd'],\n        [100, 'c'],\n        [90, 'xc'],\n        [50, 'l'],\n        [40, 'xl'],\n        [10, 'x'],\n        [9, 'ix'],\n        [5, 'v'],\n        [4, 'iv'],\n        [1, 'i']\n    ];\n\n    const romanValues = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1};\n\n    /**\n     * converts a number to roman numerals\n     * @param {number} value - the number\n     * @returns {string} - the number in roman numerals\n     */\n    function decimalToRoman(value) {\n        for (var index = 0; index < romanNumerals.length; index++) {\n            const numeral = romanNumerals[index];\n            if (value >= numeral[0]) {\n                return numeral[1] + decimalToRoman(value - numeral[0]);\n            }\n        }\n        return '';\n    }\n\n    /**\n     * converts roman numerals to a number\n     * @param {string} roman - roman number\n     * @returns {number} - the numeric value\n     */\n    function romanToDecimal(roman) {\n        var decimal = 0;\n        var max = 1;\n        for (var i = roman.length - 1; i >= 0; i--) {\n            const digit = roman[i];\n            const value = romanValues[digit];\n            if (value < max) {\n                decimal -= value;\n            } else {\n                max = value;\n                decimal += value;\n            }\n        }\n        return decimal;\n    }\n\n    /**\n     * converts a number to spreadsheet style letters\n     * @param {number} value - the number\n     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'\n     * @returns {string} - the letters\n     */\n    function decimalToLetters(value, aChar) {\n        var letters = [];\n        var aCode = aChar.charCodeAt(0);\n        while (value > 0) {\n            letters.unshift(String.fromCharCode((value - 1) % 26 + aCode));\n            value = Math.floor((value - 1) / 26);\n        }\n        return letters.join('');\n    }\n\n    /**\n     * converts spreadsheet style letters to a number\n     * @param {string} letters - the letters\n     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'\n     * @returns {number} - the numeric value\n     */\n    function lettersToDecimal(letters, aChar) {\n        var aCode = aChar.charCodeAt(0);\n        var decimal = 0;\n        for (var i = 0; i < letters.length; i++) {\n            decimal += (letters.charCodeAt(letters.length - i - 1) - aCode + 1) * Math.pow(26, i);\n        }\n        return decimal;\n    }\n\n    /**\n     * Formats an integer as specified by the XPath fn:format-integer function\n     * See https://www.w3.org/TR/xpath-functions-31/#func-format-integer\n     * @param {number} value - the number to be formatted\n     * @param {string} picture - the picture string that specifies the format\n     * @returns {string} - the formatted number\n     */\n    function formatInteger(value, picture) {\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        value = Math.floor(value);\n\n        const format = analyseIntegerPicture(picture);\n        return _formatInteger(value, format);\n    }\n\n    const formats = {\n        DECIMAL: 'decimal',\n        LETTERS: 'letters',\n        ROMAN: 'roman',\n        WORDS: 'words',\n        SEQUENCE: 'sequence'\n    };\n\n    const tcase = {\n        UPPER: 'upper',\n        LOWER: 'lower',\n        TITLE: 'title'\n    };\n\n    /**\n     * formats an integer using a preprocessed representation of the picture string\n     * @param {number} value - the number to be formatted\n     * @param {object} format - the preprocessed representation of the pucture string\n     * @returns {string} - the formatted number\n     * @private\n     */\n    function _formatInteger(value, format) {\n        let formattedInteger;\n        const negative = value < 0;\n        value = Math.abs(value);\n        switch (format.primary) {\n            case formats.LETTERS:\n                formattedInteger = decimalToLetters(value, format.case === tcase.UPPER ? 'A' : 'a');\n                break;\n            case formats.ROMAN:\n                formattedInteger = decimalToRoman(value);\n                if (format.case === tcase.UPPER) {\n                    formattedInteger = formattedInteger.toUpperCase();\n                }\n                break;\n            case formats.WORDS:\n                formattedInteger = numberToWords(value, format.ordinal);\n                if (format.case === tcase.UPPER) {\n                    formattedInteger = formattedInteger.toUpperCase();\n                } else if (format.case === tcase.LOWER) {\n                    formattedInteger = formattedInteger.toLowerCase();\n                }\n                break;\n            case formats.DECIMAL:\n                formattedInteger = '' + value;\n                // TODO use functionPad\n                var padLength = format.mandatoryDigits - formattedInteger.length;\n                if (padLength > 0) {\n                    var padding = (new Array(padLength + 1)).join('0');\n                    formattedInteger = padding + formattedInteger;\n                }\n                if (format.zeroCode !== 0x30) {\n                    formattedInteger = stringToArray(formattedInteger).map(code => {\n                        return String.fromCodePoint(code.codePointAt(0) + format.zeroCode - 0x30);\n                    }).join('');\n                }\n                // insert the grouping-separator-signs, if any\n                if (format.regular) {\n                    const n = Math.floor((formattedInteger.length - 1) / format.groupingSeparators.position);\n                    for (let ii = n; ii > 0; ii--) {\n                        const pos = formattedInteger.length - ii * format.groupingSeparators.position;\n                        formattedInteger = formattedInteger.substr(0, pos) + format.groupingSeparators.character + formattedInteger.substr(pos);\n                    }\n                } else {\n                    format.groupingSeparators.reverse().forEach(separator => {\n                        const pos = formattedInteger.length - separator.position;\n                        formattedInteger = formattedInteger.substr(0, pos) + separator.character + formattedInteger.substr(pos);\n                    });\n                }\n\n                if (format.ordinal) {\n                    var suffix123 = {'1': 'st', '2': 'nd', '3': 'rd'};\n                    var lastDigit = formattedInteger[formattedInteger.length - 1];\n                    var suffix = suffix123[lastDigit];\n                    if (!suffix || (formattedInteger.length > 1 && formattedInteger[formattedInteger.length - 2] === '1')) {\n                        suffix = 'th';\n                    }\n                    formattedInteger = formattedInteger + suffix;\n                }\n                break;\n            case formats.SEQUENCE:\n                throw {\n                    code: 'D3130',\n                    value: format.token\n                };\n        }\n        if (negative) {\n            formattedInteger = '-' + formattedInteger;\n        }\n\n        return formattedInteger;\n    }\n\n    //TODO what about decimal groups in the unicode supplementary planes (surrogate pairs) ???\n    const decimalGroups = [0x30, 0x0660, 0x06F0, 0x07C0, 0x0966, 0x09E6, 0x0A66, 0x0AE6, 0x0B66, 0x0BE6, 0x0C66, 0x0CE6, 0x0D66, 0x0DE6, 0x0E50, 0x0ED0, 0x0F20, 0x1040, 0x1090, 0x17E0, 0x1810, 0x1946, 0x19D0, 0x1A80, 0x1A90, 0x1B50, 0x1BB0, 0x1C40, 0x1C50, 0xA620, 0xA8D0, 0xA900, 0xA9D0, 0xA9F0, 0xAA50, 0xABF0, 0xFF10];\n\n    /**\n     * preprocesses the picture string\n     * @param {string} picture - picture string\n     * @returns {{type: string, primary: string, case: string, ordinal: boolean}} - analysed picture\n     */\n    function analyseIntegerPicture(picture) {\n        const format = {\n            type: 'integer',\n            primary: formats.DECIMAL,\n            case: tcase.LOWER,\n            ordinal: false\n        };\n\n        let primaryFormat, formatModifier;\n        const semicolon = picture.lastIndexOf(';');\n        if (semicolon === -1) {\n            primaryFormat = picture;\n        } else {\n            primaryFormat = picture.substring(0, semicolon);\n            formatModifier = picture.substring(semicolon + 1);\n            if (formatModifier[0] === 'o') {\n                format.ordinal = true;\n            }\n        }\n\n        /* eslnt-disable-next no-fallthrough */\n        switch (primaryFormat) {\n            case 'A':\n                format.case = tcase.UPPER;\n            /* eslnt-disable-next-line no-fallthrough */\n            case 'a':\n                format.primary = formats.LETTERS;\n                break;\n            case 'I':\n                format.case = tcase.UPPER;\n            /* eslnt-disable-next-line no-fallthrough */\n            case 'i':\n                format.primary = formats.ROMAN;\n                break;\n            case 'W':\n                format.case = tcase.UPPER;\n                format.primary = formats.WORDS;\n                break;\n            case 'Ww':\n                format.case = tcase.TITLE;\n                format.primary = formats.WORDS;\n                break;\n            case 'w':\n                format.primary = formats.WORDS;\n                break;\n            default: {\n                // this is a decimal-digit-pattern if it contains a decimal digit (from any unicode decimal digit group)\n                let zeroCode = null;\n                let mandatoryDigits = 0;\n                let optionalDigits = 0;\n                let groupingSeparators = [];\n                let separatorPosition = 0;\n                const formatCodepoints = stringToArray(primaryFormat).map(c => c.codePointAt(0)).reverse(); // reverse the array to determine positions of grouping-separator-signs\n                formatCodepoints.forEach((codePoint) => {\n                    // step though each char in the picture to determine the digit group\n                    let digit = false;\n                    for (let ii = 0; ii < decimalGroups.length; ii++) {\n                        const group = decimalGroups[ii];\n                        if (codePoint >= group && codePoint <= group + 9) {\n                            // codepoint is part of this decimal group\n                            digit = true;\n                            mandatoryDigits++;\n                            separatorPosition++;\n                            if (zeroCode === null) {\n                                zeroCode = group;\n                            } else if (group !== zeroCode) {\n                                // error! different decimal groups in the same pattern\n                                throw {\n                                    code: 'D3131'\n                                };\n                            }\n                            break;\n                        }\n                    }\n                    if (!digit) {\n                        if (codePoint === 0x23) { // # - optional-digit-sign\n                            separatorPosition++;\n                            optionalDigits++;\n                        } else {\n                            // neither a decimal-digit-sign ot optional-digit-sign, assume it is a grouping-separator-sign\n                            groupingSeparators.push({\n                                position: separatorPosition,\n                                character: String.fromCodePoint(codePoint)\n                            });\n                        }\n                    }\n                });\n                if (mandatoryDigits > 0) {\n                    format.primary = formats.DECIMAL;\n                    // TODO validate decimal-digit-pattern\n\n                    // the decimal digit family (codepoint offset)\n                    format.zeroCode = zeroCode;\n                    // the number of mandatory digits\n                    format.mandatoryDigits = mandatoryDigits;\n                    // the number of optional digits\n                    format.optionalDigits = optionalDigits;\n                    // grouping separator template\n                    // are the grouping-separator-signs 'regular'?\n                    const regularRepeat = function (separators) {\n                        // are the grouping positions regular? i.e. same interval between each of them\n                        // is there at least one separator?\n                        if (separators.length === 0) {\n                            return 0;\n                        }\n                        // are all the characters the same?\n                        const sepChar = separators[0].character;\n                        for (let ii = 1; ii < separators.length; ii++) {\n                            if (separators[ii].character !== sepChar) {\n                                return 0;\n                            }\n                        }\n                        // are they equally spaced?\n                        const indexes = separators.map(separator => separator.position);\n                        const gcd = function (a, b) {\n                            return b === 0 ? a : gcd(b, a % b);\n                        };\n                        // find the greatest common divisor of all the positions\n                        const factor = indexes.reduce(gcd);\n                        // is every position separated by this divisor? If so, it's regular\n                        for (let index = 1; index <= indexes.length; index++) {\n                            if (indexes.indexOf(index * factor) === -1) {\n                                return 0;\n                            }\n                        }\n                        return factor;\n                    };\n\n                    const regular = regularRepeat(groupingSeparators);\n                    if (regular > 0) {\n                        format.regular = true;\n                        format.groupingSeparators = {\n                            position: regular,\n                            character: groupingSeparators[0].character\n                        };\n                    } else {\n                        format.regular = false;\n                        format.groupingSeparators = groupingSeparators;\n                    }\n\n                } else {\n                    // this is a 'numbering sequence' which the spec says is implementation-defined\n                    // this implementation doesn't support any numbering sequences at the moment.\n                    format.primary = formats.SEQUENCE;\n                    format.token = primaryFormat;\n                }\n            }\n        }\n\n        return format;\n    }\n\n    const defaultPresentationModifiers = {\n        Y: '1', M: '1', D: '1', d: '1', F: 'n', W: '1', w: '1', X: '1', x: '1', H: '1', h: '1',\n        P: 'n', m: '01', s: '01', f: '1', Z: '01:01', z: '01:01', C: 'n', E: 'n'\n    };\n\n    // §9.8.4.1 the format specifier is an array of string literals and variable markers\n    /**\n     * analyse the date-time picture string\n     * @param {string} picture - picture string\n     * @returns {{type: string, parts: Array}} - the analysed string\n     */\n    function analyseDateTimePicture(picture) {\n        var spec = [];\n        const format = {\n            type: 'datetime',\n            parts: spec\n        };\n        const addLiteral = function (start, end) {\n            if (end > start) {\n                let literal = picture.substring(start, end);\n                // replace any doubled ]] with single ]\n                // what if there are instances of single ']' ? - the spec doesn't say\n                literal = literal.split(']]').join(']');\n                spec.push({type: 'literal', value: literal});\n            }\n        };\n\n        var start = 0, pos = 0;\n        while (pos < picture.length) {\n            if (picture.charAt(pos) === '[') {\n                // check it's not a doubled [[\n                if (picture.charAt(pos + 1) === '[') {\n                    // literal [\n                    addLiteral(start, pos);\n                    spec.push({type: 'literal', value: '['});\n                    pos += 2;\n                    start = pos;\n                    continue;\n                }\n                // start of variable marker\n                // push the string literal (if there is one) onto the array\n                addLiteral(start, pos);\n                start = pos;\n                // search forward to closing ]\n                pos = picture.indexOf(']', start);\n                // TODO handle error case if pos === -1\n                if(pos === -1) {\n                    // error - no closing bracket\n                    throw {\n                        code: 'D3135'\n                    };\n                }\n                let marker = picture.substring(start + 1, pos);\n                // whitespace within a variable marker is ignored (i.e. remove it)\n                marker = marker.split(/\\s+/).join('');\n                var def = {\n                    type: 'marker',\n                    component: marker.charAt(0)  // 1. The component specifier is always present and is always a single letter.\n                };\n                var comma = marker.lastIndexOf(','); // 2. The width modifier may be recognized by the presence of a comma\n                var presMod; // the presentation modifiers\n                if (comma !== -1) {\n                    // §9.8.4.2 The Width Modifier\n                    const widthMod = marker.substring(comma + 1);\n                    const dash = widthMod.indexOf('-');\n                    let min, max;\n                    const parseWidth = function (wm) {\n                        if (typeof wm === 'undefined' || wm === '*') {\n                            return undefined;\n                        } else {\n                            // TODO validate wm is an unsigned int\n                            return parseInt(wm);\n                        }\n                    };\n                    if (dash === -1) {\n                        min = widthMod;\n                    } else {\n                        min = widthMod.substring(0, dash);\n                        max = widthMod.substring(dash + 1);\n                    }\n                    const widthDef = {\n                        min: parseWidth(min),\n                        max: parseWidth(max)\n                    };\n                    def.width = widthDef;\n                    presMod = marker.substring(1, comma);\n                } else {\n                    presMod = marker.substring(1);\n                }\n                if (presMod.length === 1) {\n                    def.presentation1 = presMod; // first presentation modifier\n                    //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture\n                } else if (presMod.length > 1) {\n                    var lastChar = presMod.charAt(presMod.length - 1);\n                    if ('atco'.indexOf(lastChar) !== -1) {\n                        def.presentation2 = lastChar;\n                        if (lastChar === 'o') {\n                            def.ordinal = true;\n                        }\n                        // 'c' means 'cardinal' and is the default (i.e. not 'ordinal')\n                        // 'a' & 't' are ignored (not sure of their relevance to English numbering)\n                        def.presentation1 = presMod.substring(0, presMod.length - 1);\n                    } else {\n                        def.presentation1 = presMod;\n                        //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture,\n                        // doesn't use ] as grouping separator, and if grouping separator is , then must have width modifier\n                    }\n                } else {\n                    // no presentation modifier specified - apply the default;\n                    def.presentation1 = defaultPresentationModifiers[def.component];\n                }\n                if (typeof def.presentation1 === 'undefined') {\n                    // unknown component specifier\n                    throw {\n                        code: 'D3132',\n                        value: def.component\n                    };\n                }\n                if (def.presentation1[0] === 'n') {\n                    def.names = tcase.LOWER;\n                } else if (def.presentation1[0] === 'N') {\n                    if (def.presentation1[1] === 'n') {\n                        def.names = tcase.TITLE;\n                    } else {\n                        def.names = tcase.UPPER;\n                    }\n                } else if ('YMDdFWwXxHhmsf'.indexOf(def.component) !== -1) {\n                    var integerPattern = def.presentation1;\n                    if (def.presentation2) {\n                        integerPattern += ';' + def.presentation2;\n                    }\n                    def.integerFormat = analyseIntegerPicture(integerPattern);\n                    if (def.width && def.width.min !== undefined) {\n                        if (def.integerFormat.mandatoryDigits < def.width.min) {\n                            def.integerFormat.mandatoryDigits = def.width.min;\n                        }\n                    }\n                    if ('YMD'.indexOf(def.component) !== -1) {\n                        // §9.8.4.4\n                        def.n = -1;\n                        if (def.width && def.width.max !== undefined) {\n                            def.n = def.width.max;\n                            def.integerFormat.mandatoryDigits = def.n;\n                        } else {\n                            var w = def.integerFormat.mandatoryDigits + def.integerFormat.optionalDigits;\n                            if (w >= 2) {\n                                def.n = w;\n                            }\n                        }\n                    }\n                }\n                if (def.component === 'Z' || def.component === 'z') {\n                    def.integerFormat = analyseIntegerPicture(def.presentation1);\n                }\n                spec.push(def);\n                start = pos + 1;\n            }\n            pos++;\n        }\n        addLiteral(start, pos);\n        return format;\n    }\n\n    const days = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\n    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n    const millisInADay = 1000 * 60 * 60 * 24;\n\n    const startOfFirstWeek = function (ym) {\n        // ISO 8601 defines the first week of the year to be the week that contains the first Thursday\n        // XPath F&O extends this same definition for the first week of a month\n        // the week starts on a Monday - calculate the millis for the start of the first week\n        // millis for given 1st Jan of that year (at 00:00 UTC)\n        const jan1 = Date.UTC(ym.year, ym.month);\n        var dayOfJan1 = (new Date(jan1)).getUTCDay();\n        if (dayOfJan1 === 0) {\n            dayOfJan1 = 7;\n        }\n        // if Jan 1 is Fri, Sat or Sun, then add the number of days (in millis) to jan1 to get the start of week 1\n        return dayOfJan1 > 4 ? jan1 + (8 - dayOfJan1) * millisInADay : jan1 - (dayOfJan1 - 1) * millisInADay;\n    };\n\n    const yearMonth = function (year, month) {\n        return {\n            year: year,\n            month: month,\n            nextMonth: function () {\n                return (month === 11) ? yearMonth(year + 1, 0) : yearMonth(year, month + 1);\n            },\n            previousMonth: function () {\n                return (month === 0) ? yearMonth(year - 1, 11) : yearMonth(year, month - 1);\n            },\n            nextYear: function () {\n                return yearMonth(year + 1, month);\n            },\n            previousYear: function () {\n                return yearMonth(year - 1, month);\n            }\n        };\n    };\n\n    const deltaWeeks = function (start, end) {\n        return (end - start) / (millisInADay * 7) + 1;\n    };\n\n    const getDateTimeFragment = (date, component) => {\n        let componentValue;\n        switch (component) {\n            case 'Y': // year\n                componentValue = date.getUTCFullYear();\n                break;\n            case 'M': // month in year\n                componentValue = date.getUTCMonth() + 1;\n                break;\n            case 'D': // day in month\n                componentValue = date.getUTCDate();\n                break;\n            case 'd': { // day in year\n                // millis for given date (at 00:00 UTC)\n                const today = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());\n                // millis for given 1st Jan of that year (at 00:00 UTC)\n                const firstJan = Date.UTC(date.getUTCFullYear(), 0);\n                componentValue = (today - firstJan) / millisInADay + 1;\n                break;\n            }\n            case 'F': // day of week\n                componentValue = date.getUTCDay();\n                if (componentValue === 0) {\n                    // ISO 8601 defines days 1-7: Mon-Sun\n                    componentValue = 7;\n                }\n                break;\n            case 'W': { // week in year\n                const thisYear = yearMonth(date.getUTCFullYear(), 0);\n                const startOfWeek1 = startOfFirstWeek(thisYear);\n                const today = Date.UTC(thisYear.year, date.getUTCMonth(), date.getUTCDate());\n                let week = deltaWeeks(startOfWeek1, today);\n                if (week > 52) {\n                    // might be first week of the following year\n                    const startOfFollowingYear = startOfFirstWeek(thisYear.nextYear());\n                    if (today >= startOfFollowingYear) {\n                        week = 1;\n                    }\n                } else if (week < 1) {\n                    // must be end of the previous year\n                    const startOfPreviousYear = startOfFirstWeek(thisYear.previousYear());\n                    week = deltaWeeks(startOfPreviousYear, today);\n                }\n                componentValue = Math.floor(week);\n                break;\n            }\n            case 'w': { // week in month\n                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());\n                const startOfWeek1 = startOfFirstWeek(thisMonth);\n                const today = Date.UTC(thisMonth.year, thisMonth.month, date.getUTCDate());\n                let week = deltaWeeks(startOfWeek1, today);\n                if (week > 4) {\n                    // might be first week of the following month\n                    const startOfFollowingMonth = startOfFirstWeek(thisMonth.nextMonth());\n                    if (today >= startOfFollowingMonth) {\n                        week = 1;\n                    }\n                } else if (week < 1) {\n                    // must be end of the previous month\n                    const startOfPreviousMonth = startOfFirstWeek(thisMonth.previousMonth());\n                    week = deltaWeeks(startOfPreviousMonth, today);\n                }\n                componentValue = Math.floor(week);\n                break;\n            }\n            case 'X': { // ISO week-numbering year\n                // Extension: The F&O spec says nothing about how to access the year associated with the week-of-the-year\n                // e.g. Sat 1 Jan 2005 is in the 53rd week of 2004.\n                // The 'W' component specifier gives 53, but 'Y' will give 2005.\n                // I propose to add 'X' as the component specifier to give the ISO week-numbering year (2004 in this example)\n                const thisYear = yearMonth(date.getUTCFullYear(), 0);\n                const startOfISOYear = startOfFirstWeek(thisYear);\n                const endOfISOYear = startOfFirstWeek(thisYear.nextYear());\n                const now = date.getTime();\n                if (now < startOfISOYear) {\n                    componentValue = thisYear.year - 1;\n                } else if (now >= endOfISOYear) {\n                    componentValue = thisYear.year + 1;\n                } else {\n                    componentValue = thisYear.year;\n                }\n                break;\n            }\n            case 'x': { // ISO week-numbering month\n                // Extension: The F&O spec says nothing about how to access the month associated with the week-of-the-month\n                // e.g. Sat 1 Jan 2005 is in the 5th week of December 2004.\n                // The 'w' component specifier gives 5, but 'W' will give January and 'Y' will give 2005.\n                // I propose to add 'x' as the component specifier to give the 'week-numbering' month (December in this example)\n                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());\n                const startOfISOMonth = startOfFirstWeek(thisMonth);\n                const nextMonth = thisMonth.nextMonth();\n                const endOfISOMonth = startOfFirstWeek(nextMonth);\n                const now = date.getTime();\n                if (now < startOfISOMonth) {\n                    componentValue = thisMonth.previousMonth().month + 1;\n                } else if (now >= endOfISOMonth) {\n                    componentValue = nextMonth.month + 1;\n                } else {\n                    componentValue = thisMonth.month + 1;\n                }\n                break;\n            }\n            case 'H': // hour in day (24 hours)\n                componentValue = date.getUTCHours();\n                break;\n            case 'h': // hour in half-day (12 hours)\n                componentValue = date.getUTCHours();\n                componentValue = componentValue % 12;\n                if (componentValue === 0) {\n                    componentValue = 12;\n                }\n                break;\n            case 'P': // am/pm marker\n                componentValue = date.getUTCHours() >= 12 ? 'pm' : 'am';\n                break;\n            case 'm': // minute in hour\n                componentValue = date.getUTCMinutes();\n                break;\n            case 's': // second in minute\n                componentValue = date.getUTCSeconds();\n                break;\n            case 'f': // fractional seconds\n                componentValue = date.getUTCMilliseconds();\n                break;\n            case 'Z': // timezone\n            case 'z':\n                // since the date object is constructed from epoch millis, the TZ component is always be UTC.\n                break;\n            case 'C': // calendar name\n                componentValue = 'ISO';\n                break;\n            case 'E': // era\n                componentValue = 'ISO';\n                break;\n        }\n        return componentValue;\n    };\n\n    let iso8601Spec = null;\n\n    /**\n     * formats the date/time as specified by the XPath fn:format-dateTime function\n     * @param {number} millis - the timestamp to be formatted, in millis since the epoch\n     * @param {string} picture - the picture string that specifies the format\n     * @param {string} timezone - the timezone to use\n     * @returns {string} - the formatted timestamp\n     */\n    function formatDateTime(millis, picture, timezone) {\n        var offsetHours = 0;\n        var offsetMinutes = 0;\n\n        if (typeof timezone !== 'undefined') {\n            // parse the hour and minute offsets\n            // assume for now the format supplied is +hhmm\n            const offset = parseInt(timezone);\n            offsetHours = Math.floor(offset / 100);\n            offsetMinutes = offset % 100;\n        }\n\n        var formatComponent = function (date, markerSpec) {\n            var componentValue = getDateTimeFragment(date, markerSpec.component);\n\n            // §9.8.4.3 Formatting Integer-Valued Date/Time Components\n            if ('YMDdFWwXxHhms'.indexOf(markerSpec.component) !== -1) {\n                if (markerSpec.component === 'Y') {\n                    // §9.8.4.4 Formatting the Year Component\n                    if (markerSpec.n !== -1) {\n                        componentValue = componentValue % Math.pow(10, markerSpec.n);\n                    }\n                }\n                if (markerSpec.names) {\n                    if (markerSpec.component === 'M' || markerSpec.component === 'x') {\n                        componentValue = months[componentValue - 1];\n                    } else if (markerSpec.component === 'F') {\n                        componentValue = days[componentValue];\n                    } else {\n                        throw {\n                            code: 'D3133',\n                            value: markerSpec.component\n                        };\n                    }\n                    if (markerSpec.names === tcase.UPPER) {\n                        componentValue = componentValue.toUpperCase();\n                    } else if (markerSpec.names === tcase.LOWER) {\n                        componentValue = componentValue.toLowerCase();\n                    }\n                    if (markerSpec.width && componentValue.length > markerSpec.width.max) {\n                        componentValue = componentValue.substring(0, markerSpec.width.max);\n                    }\n                } else {\n                    componentValue = _formatInteger(componentValue, markerSpec.integerFormat);\n                }\n            } else if (markerSpec.component === 'f') {\n                // TODO §9.8.4.5 Formatting Fractional Seconds\n                componentValue = _formatInteger(componentValue, markerSpec.integerFormat);\n            } else if (markerSpec.component === 'Z' || markerSpec.component === 'z') {\n                // §9.8.4.6 Formatting timezones\n                const offset = offsetHours * 100 + offsetMinutes;\n                if (markerSpec.integerFormat.regular) {\n                    componentValue = _formatInteger(offset, markerSpec.integerFormat);\n                } else {\n                    const numDigits = markerSpec.integerFormat.mandatoryDigits;\n                    if (numDigits === 1 || numDigits === 2) {\n                        componentValue = _formatInteger(offsetHours, markerSpec.integerFormat);\n                        if (offsetMinutes !== 0) {\n                            componentValue += ':' + formatInteger(offsetMinutes, '00');\n                        }\n                    } else if (numDigits === 3 || numDigits === 4) {\n                        componentValue = _formatInteger(offset, markerSpec.integerFormat);\n                    } else {\n                        throw {\n                            code: 'D3134',\n                            value: numDigits\n                        };\n                    }\n                }\n                if (offset >= 0) {\n                    componentValue = '+' + componentValue;\n                }\n                if (markerSpec.component === 'z') {\n                    componentValue = 'GMT' + componentValue;\n                }\n                if (offset === 0 && markerSpec.presentation2 === 't') {\n                    componentValue = 'Z';\n                }\n            } else if (markerSpec.component === 'P') {\n                // §9.8.4.7 Formatting Other Components\n                // Formatting P for am/pm\n                // getDateTimeFragment() always returns am/pm lower case so check for UPPER here\n                if (markerSpec.names === tcase.UPPER) {\n                    componentValue = componentValue.toUpperCase();\n                }\n            }\n            return componentValue;\n        };\n\n        let formatSpec;\n        if(typeof picture === 'undefined') {\n            // default to ISO 8601 format\n            if (iso8601Spec === null) {\n                iso8601Spec = analyseDateTimePicture('[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01].[f001][Z01:01t]');\n            }\n            formatSpec = iso8601Spec;\n        } else {\n            formatSpec = analyseDateTimePicture(picture);\n        }\n\n        const offsetMillis = (60 * offsetHours + offsetMinutes) * 60 * 1000;\n        const dateTime = new Date(millis + offsetMillis);\n\n        let result = '';\n        formatSpec.parts.forEach(function (part) {\n            if (part.type === 'literal') {\n                result += part.value;\n            } else {\n                result += formatComponent(dateTime, part);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Generate a regex to parse integers or timestamps\n     * @param {object} formatSpec - object representing the format\n     * @returns {object} - regex\n     */\n    function generateRegex(formatSpec) {\n        var matcher = {};\n        if (formatSpec.type === 'datetime') {\n            matcher.type = 'datetime';\n            matcher.parts = formatSpec.parts.map(function (part) {\n                var res = {};\n                if (part.type === 'literal') {\n                    res.regex = part.value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                } else if (part.component === 'Z' || part.component === 'z') {\n                    // timezone\n                    let separator;\n                    if (!Array.isArray(part.integerFormat.groupingSeparators)) {\n                        separator = part.integerFormat.groupingSeparators;\n                    }\n                    res.regex = '';\n                    if (part.component === 'z') {\n                        res.regex = 'GMT';\n                    }\n                    res.regex += '[-+][0-9]+';\n                    if (separator) {\n                        res.regex += separator.character + '[0-9]+';\n                    }\n                    res.parse = function(value) {\n                        if (part.component === 'z') {\n                            value = value.substring(3); // remove the leading GMT\n                        }\n                        let offsetHours = 0, offsetMinutes = 0;\n                        if (separator) {\n                            offsetHours = Number.parseInt(value.substring(0, value.indexOf(separator.character)));\n                            offsetMinutes = Number.parseInt(value.substring(value.indexOf(separator.character) + 1));\n                        } else {\n                            // depends on number of digits\n                            const numdigits = value.length - 1;\n                            if (numdigits <= 2) {\n                                // just hour offset\n                                offsetHours = Number.parseInt(value);\n                            } else {\n                                offsetHours = Number.parseInt(value.substring(0, 3));\n                                offsetMinutes = Number.parseInt(value.substring(3));\n                            }\n                        }\n                        return offsetHours * 60 + offsetMinutes;\n                    };\n                } else if (part.integerFormat) {\n                    part.integerFormat.n = part.n;\n                    res = generateRegex(part.integerFormat);\n                } else {\n                    // must be a month or day name\n                    res.regex = '[a-zA-Z]+';\n                    var lookup = {};\n                    if (part.component === 'M' || part.component === 'x') {\n                        // months\n                        months.forEach(function (name, index) {\n                            if (part.width && part.width.max) {\n                                lookup[name.substring(0, part.width.max)] = index + 1;\n                            } else {\n                                lookup[name] = index + 1;\n                            }\n                        });\n                    } else if (part.component === 'F') {\n                        // days\n                        days.forEach(function (name, index) {\n                            if (index > 0) {\n                                if (part.width && part.width.max) {\n                                    lookup[name.substring(0, part.width.max)] = index;\n                                } else {\n                                    lookup[name] = index;\n                                }\n                            }\n                        });\n                    } else if (part.component === 'P') {\n                        lookup = {'am': 0, 'AM': 0, 'pm': 1, 'PM': 1};\n                    } else {\n                        // unsupported 'name' option for this component\n                        throw {\n                            code: 'D3133',\n                            value: part.component\n                        };\n                    }\n                    res.parse = function (value) {\n                        return lookup[value];\n                    };\n                }\n                res.component = part.component;\n                return res;\n            });\n        } else { // type === 'integer'\n            matcher.type = 'integer';\n            const isUpper = formatSpec.case === tcase.UPPER;\n            let occurrences;\n            if(formatSpec.n && formatSpec.n > 0){\n                if(formatSpec.optionalDigits === 0){\n                    occurrences = `{${formatSpec.n}}`;\n                } else {\n                    occurrences = `{${formatSpec.n - formatSpec.optionalDigits},${formatSpec.n}}`;\n                }\n            } else {\n                occurrences = '+';\n            }\n\n            switch (formatSpec.primary) {\n                case formats.LETTERS:\n                    matcher.regex = isUpper ? '[A-Z]+' : '[a-z]+';\n                    matcher.parse = function (value) {\n                        return lettersToDecimal(value, isUpper ? 'A' : 'a');\n                    };\n                    break;\n                case formats.ROMAN:\n                    matcher.regex = isUpper ? '[MDCLXVI]+' : '[mdclxvi]+';\n                    matcher.parse = function (value) {\n                        return romanToDecimal(isUpper ? value : value.toUpperCase());\n                    };\n                    break;\n                case formats.WORDS:\n                    matcher.regex = '(?:' + Object.keys(wordValues).concat('and', '[\\\\-, ]').join('|') + ')+';\n                    matcher.parse = function (value) {\n                        return wordsToNumber(value.toLowerCase());\n                    };\n                    break;\n                case formats.DECIMAL:\n                    matcher.regex = `[0-9]${occurrences}`;\n                    if (formatSpec.ordinal) {\n                        // ordinals\n                        matcher.regex += '(?:th|st|nd|rd)';\n                    }\n                    matcher.parse = function (value) {\n                        let digits = value;\n                        if (formatSpec.ordinal) {\n                            // strip off the suffix\n                            digits = value.substring(0, value.length - 2);\n                        }\n                        // strip out the separators\n                        if (formatSpec.regular) {\n                            digits = digits.split(',').join('');\n                        } else {\n                            formatSpec.groupingSeparators.forEach(sep => {\n                                digits = digits.split(sep.character).join('');\n                            });\n                        }\n                        if (formatSpec.zeroCode !== 0x30) {\n                            // apply offset\n                            digits = digits.split('').map(char => String.fromCodePoint(char.codePointAt(0) - formatSpec.zeroCode + 0x30)).join('');\n                        }\n                        return parseInt(digits);\n                    };\n                    break;\n                case formats.SEQUENCE:\n                    throw {\n                        code: 'D3130',\n                        value: formatSpec.token\n                    };\n            }\n\n        }\n        return matcher;\n    }\n\n    /**\n     * parse a string containing an integer as specified by the picture string\n     * @param {string} value - the string to parse\n     * @param {string} picture - the picture string\n     * @returns {number} - the parsed number\n     */\n    function parseInteger(value, picture) {\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        const formatSpec = analyseIntegerPicture(picture);\n        const matchSpec = generateRegex(formatSpec);\n        //const fullRegex = '^' + matchSpec.regex + '$';\n        //const matcher = new RegExp(fullRegex);\n        // TODO validate input based on the matcher regex\n        const result = matchSpec.parse(value);\n        return result;\n    }\n\n    /**\n     * parse a string containing a timestamp as specified by the picture string\n     * @param {string} timestamp - the string to parse\n     * @param {string} picture - the picture string\n     * @returns {number} - the parsed timestamp in millis since the epoch\n     */\n    function parseDateTime(timestamp, picture) {\n        const formatSpec = analyseDateTimePicture(picture);\n        const matchSpec = generateRegex(formatSpec);\n        const fullRegex = '^' + matchSpec.parts.map(part => '(' + part.regex + ')').join('') + '$';\n\n        const matcher = new RegExp(fullRegex, 'i'); // TODO can cache this against the picture\n        var info = matcher.exec(timestamp);\n        if (info !== null) {\n            // validate what we've just parsed - do we have enough information to create a timestamp?\n            // rules:\n            // The date is specified by one of:\n            //    {Y, M, D}    (dateA)\n            // or {Y, d}       (dateB)\n            // or {Y, x, w, F} (dateC)\n            // or {X, W, F}    (dateD)\n            // The time is specified by one of:\n            //    {H, m, s, f}    (timeA)\n            // or {P, h, m, s, f} (timeB)\n            // All sets can have an optional Z\n            // To create a timestamp (epoch millis) we need both date and time, but we can default missing\n            // information according to the following rules:\n            // - line up one combination of the above from date, and one from time, most significant value (MSV) to least significant (LSV\n            // - for the values that have been captured, if there are any gaps between MSV and LSV, then throw an error\n            //     (e.g.) if hour and seconds, but not minutes is given - throw\n            //     (e.g.) if month, hour and minutes, but not day-of-month is given - throw\n            // - anything right of the LSV should be defaulted to zero\n            //     (e.g.) if hour and minutes given, default seconds and fractional seconds to zero\n            //     (e.g.) if date only given, default the time to 0:00:00.000 (midnight)\n            // - anything left of the MSV should be defaulted to the value of that component returned by $now()\n            //     (e.g.) if time only given, default the date to today\n            //     (e.g.) if month and date given, default to this year (and midnight, by previous rule)\n            //   -- default values for X, x, W, w, F will be derived from the values returned by $now()\n\n            // implement the above rules\n            // determine which of the above date/time combinations we have by using bit masks\n\n            //        Y X M x W w d D F P H h m s f Z\n            // dateA  1 0 1 0 0 0 0 1 ?                     0 - must not appear\n            // dateB  1 0 0 0 0 0 1 0 ?                     1 - can appear - relevant\n            // dateC  0 1 0 1 0 1 0 0 1                     ? - can appear - ignored\n            // dateD  0 1 0 0 1 0 0 0 1\n            // timeA                    0 1 0 1 1 1\n            // timeB                    1 0 1 1 1 1\n\n            // create bitmasks based on the above\n            //    date mask             YXMxWwdD\n            const dmA = 161;  // binary 10100001\n            const dmB = 130;  // binary 10000010\n            const dmC = 84;   // binary 01010100\n            const dmD = 72;   // binary 01001000\n            //    time mask             PHhmsf\n            const tmA = 23;   // binary 010111\n            const tmB = 47;   // binary 101111\n\n            const components = {};\n            for (let i = 1; i < info.length; i++) {\n                const mpart = matchSpec.parts[i - 1];\n                if (mpart.parse) {\n                    components[mpart.component] = mpart.parse(info[i]);\n                }\n            }\n\n            if(Object.getOwnPropertyNames(components).length === 0) {\n                // nothing specified\n                return undefined;\n            }\n\n            let mask = 0;\n\n            const shift = bit => {\n                mask <<= 1;\n                mask += bit ? 1 : 0;\n            };\n\n            const isType = type => {\n                // shouldn't match any 0's, must match at least one 1\n                return !(~type & mask) && !!(type & mask);\n            };\n\n            'YXMxWwdD'.split('').forEach(part => shift(components[part]));\n\n            const dateA = isType(dmA);\n            const dateB = !dateA && isType(dmB);\n            const dateC = isType(dmC);\n            const dateD = !dateC && isType(dmD);\n\n            mask = 0;\n            'PHhmsf'.split('').forEach(part => shift(components[part]));\n\n            const timeA = isType(tmA);\n            const timeB = !timeA && isType(tmB);\n\n            // should only be zero or one date type and zero or one time type\n\n            const dateComps = dateB ? 'YD' : dateC ? 'XxwF' : dateD? 'XWF' : 'YMD';\n            const timeComps = timeB ? 'Phmsf' : 'Hmsf';\n\n            const comps = dateComps + timeComps;\n\n            // step through the candidate parts from most significant to least significant\n            // default the most significant unspecified parts to current timestamp component\n            // default the least significant unspecified parts to zero\n            // if any gaps in between the specified parts, throw an error\n\n            const now = this.environment.timestamp; // must get the fixed timestamp from jsonata\n\n            let startSpecified = false;\n            let endSpecified = false;\n            comps.split('').forEach(part => {\n                if(typeof components[part] === 'undefined') {\n                    if(startSpecified) {\n                        // past the specified block - default to zero\n                        components[part] = ('MDd'.indexOf(part) !== -1) ? 1 : 0;\n                        endSpecified = true;\n                    } else {\n                        // haven't hit the specified block yet, default to current timestamp\n                        components[part] = getDateTimeFragment(now, part);\n                    }\n                } else {\n                    startSpecified = true;\n                    if(endSpecified) {\n                        throw {\n                            code: 'D3136'\n                        };\n                    }\n                }\n            });\n\n            // validate and fill in components\n            if (components.M > 0) {\n                components.M -= 1;  // Date.UTC requires a zero-indexed month\n            } else {\n                components.M = 0; // default to January\n            }\n            if (dateB) {\n                // millis for given 1st Jan of that year (at 00:00 UTC)\n                const firstJan = Date.UTC(components.Y, 0);\n                const offsetMillis = (components.d - 1) * 1000 * 60 * 60 * 24;\n                const derivedDate = new Date(firstJan + offsetMillis);\n                components.M = derivedDate.getUTCMonth();\n                components.D = derivedDate.getUTCDate();\n            }\n            if (dateC) {\n                // TODO implement this\n                // parsing this format not currently supported\n                throw {\n                    code: 'D3136'\n                };\n            }\n            if (dateD) {\n                // TODO implement this\n                // parsing this format (ISO week date) not currently supported\n                throw {\n                    code: 'D3136'\n                };\n            }\n            if (timeB) {\n                // 12hr to 24hr\n                components.H = components.h === 12 ? 0 : components.h;\n                if (components.P === 1) {\n                    components.H += 12;\n                }\n            }\n\n            var millis = Date.UTC(components.Y, components.M, components.D, components.H, components.m, components.s, components.f);\n            if(components.Z || components.z) {\n                // adjust for timezone\n                millis -= (components.Z || components.z) * 60 * 1000;\n            }\n            return millis;\n        }\n    }\n\n    // Regular expression to match an ISO 8601 formatted timestamp\n    var iso8601regex = new RegExp('^\\\\d{4}(-[01]\\\\d)*(-[0-3]\\\\d)*(T[0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d)*(\\\\.\\\\d+)?([+-][0-2]\\\\d:?[0-5]\\\\d|Z)?$');\n\n    /**\n     * Converts an ISO 8601 timestamp to milliseconds since the epoch\n     *\n     * @param {string} timestamp - the timestamp to be converted\n     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)\n     * @returns {Number} - milliseconds since the epoch\n     */\n    function toMillis(timestamp, picture) {\n        // undefined inputs always return undefined\n        if(typeof timestamp === 'undefined') {\n            return undefined;\n        }\n\n        if(typeof picture === 'undefined') {\n            if (!iso8601regex.test(timestamp)) {\n                throw {\n                    stack: (new Error()).stack,\n                    code: \"D3110\",\n                    value: timestamp\n                };\n            }\n\n            return Date.parse(timestamp);\n        } else {\n            return parseDateTime.call(this, timestamp, picture);\n        }\n    }\n\n    /**\n     * Converts milliseconds since the epoch to an ISO 8601 timestamp\n     * @param {Number} millis - milliseconds since the epoch to be converted\n     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)\n     * @param {string} [timezone] - the timezone to format the timestamp in (defaults to UTC)\n     * @returns {String} - the formatted timestamp\n     */\n    function fromMillis(millis, picture, timezone) {\n        // undefined inputs always return undefined\n        if(typeof millis === 'undefined') {\n            return undefined;\n        }\n\n        return formatDateTime.call(this, millis, picture, timezone);\n    }\n\n    return {\n        formatInteger, parseInteger, fromMillis, toMillis\n    };\n})();\n\nmodule.exports = dateTime;\n\n},{\"./utils\":6}],2:[function(require,module,exports){\n(function (global){(function (){\n/**\n * © Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar utils = require('./utils');\n\nconst functions = (() => {\n    'use strict';\n\n    var isNumeric = utils.isNumeric;\n    var isArrayOfStrings = utils.isArrayOfStrings;\n    var isArrayOfNumbers = utils.isArrayOfNumbers;\n    var createSequence = utils.createSequence;\n    var isSequence = utils.isSequence;\n    var isFunction = utils.isFunction;\n    var isLambda = utils.isLambda;\n    var isPromise = utils.isPromise;\n    var getFunctionArity = utils.getFunctionArity;\n    var deepEquals = utils.isDeepEqual;\n    var stringToArray = utils.stringToArray;\n\n    /**\n     * Sum function\n     * @param {Object} args - Arguments\n     * @returns {number} Total value of arguments\n     */\n    function sum(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined') {\n            return undefined;\n        }\n\n        var total = 0;\n        args.forEach(function (num) {\n            total += num;\n        });\n        return total;\n    }\n\n    /**\n     * Count function\n     * @param {Object} args - Arguments\n     * @returns {number} Number of elements in the array\n     */\n    function count(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined') {\n            return 0;\n        }\n\n        return args.length;\n    }\n\n    /**\n     * Max function\n     * @param {Object} args - Arguments\n     * @returns {number} Max element in the array\n     */\n    function max(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        return Math.max.apply(Math, args);\n    }\n\n    /**\n     * Min function\n     * @param {Object} args - Arguments\n     * @returns {number} Min element in the array\n     */\n    function min(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        return Math.min.apply(Math, args);\n    }\n\n    /**\n     * Average function\n     * @param {Object} args - Arguments\n     * @returns {number} Average element in the array\n     */\n    function average(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        var total = 0;\n        args.forEach(function (num) {\n            total += num;\n        });\n        return total / args.length;\n    }\n\n    /**\n     * Stringify arguments\n     * @param {Object} arg - Arguments\n     * @param {boolean} [prettify] - Pretty print the result\n     * @returns {String} String from arguments\n     */\n    function string(arg, prettify = false) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var str;\n\n        if (typeof arg === 'string') {\n            // already a string\n            str = arg;\n        } else if (isFunction(arg)) {\n            // functions (built-in and lambda convert to empty string\n            str = '';\n        } else if (typeof arg === 'number' && !isFinite(arg)) {\n            throw {\n                code: \"D3001\",\n                value: arg,\n                stack: (new Error()).stack\n            };\n        } else {\n            var space = prettify ? 2 : 0;\n            if(Array.isArray(arg) && arg.outerWrapper) {\n                arg = arg[0];\n            }\n            str = JSON.stringify(arg, function (key, val) {\n                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(15)) :\n                    (val && isFunction(val)) ? '' : val;\n            }, space);\n        }\n        return str;\n    }\n\n    /**\n     * Create substring based on character number and length\n     * @param {String} str - String to evaluate\n     * @param {Integer} start - Character number to start substring\n     * @param {Integer} [length] - Number of characters in substring\n     * @returns {string|*} Substring\n     */\n    function substring(str, start, length) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var strArray = stringToArray(str);\n        var strLength = strArray.length;\n\n        if (strLength + start < 0) {\n            start = 0;\n        }\n\n        if (typeof length !== 'undefined') {\n            if (length <= 0) {\n                return '';\n            }\n            var end = start >= 0 ? start + length : strLength + start + length;\n            return strArray.slice(start, end).join('');\n        }\n\n        return strArray.slice(start).join('');\n    }\n\n    /**\n     * Create substring up until a character\n     * @param {String} str - String to evaluate\n     * @param {String} chars - Character to define substring boundary\n     * @returns {*} Substring\n     */\n    function substringBefore(str, chars) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var pos = str.indexOf(chars);\n        if (pos > -1) {\n            return str.substr(0, pos);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * Create substring after a character\n     * @param {String} str - String to evaluate\n     * @param {String} chars - Character to define substring boundary\n     * @returns {*} Substring\n     */\n    function substringAfter(str, chars) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var pos = str.indexOf(chars);\n        if (pos > -1) {\n            return str.substr(pos + chars.length);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * Lowercase a string\n     * @param {String} str - String to evaluate\n     * @returns {string} Lowercase string\n     */\n    function lowercase(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return str.toLowerCase();\n    }\n\n    /**\n     * Uppercase a string\n     * @param {String} str - String to evaluate\n     * @returns {string} Uppercase string\n     */\n    function uppercase(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return str.toUpperCase();\n    }\n\n    /**\n     * length of a string\n     * @param {String} str - string\n     * @returns {Number} The number of characters in the string\n     */\n    function length(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return stringToArray(str).length;\n    }\n\n    /**\n     * Normalize and trim whitespace within a string\n     * @param {string} str - string to be trimmed\n     * @returns {string} - trimmed string\n     */\n    function trim(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // normalize whitespace\n        var result = str.replace(/[ \\t\\n\\r]+/gm, ' ');\n        if (result.charAt(0) === ' ') {\n            // strip leading space\n            result = result.substring(1);\n        }\n        if (result.charAt(result.length - 1) === ' ') {\n            // strip trailing space\n            result = result.substring(0, result.length - 1);\n        }\n        return result;\n    }\n\n    /**\n     * Pad a string to a minimum width by adding characters to the start or end\n     * @param {string} str - string to be padded\n     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left\n     * @param {string} [char] - the pad character(s); defaults to ' '\n     * @returns {string} - padded string\n     */\n    function pad(str, width, char) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        if (typeof char === 'undefined' || char.length === 0) {\n            char = ' ';\n        }\n\n        var result;\n        var padLength = Math.abs(width) - length(str);\n        if (padLength > 0) {\n            var padding = (new Array(padLength + 1)).join(char);\n            if (char.length > 1) {\n                padding = substring(padding, 0, padLength);\n            }\n            if (width > 0) {\n                result = str + padding;\n            } else {\n                result = padding + str;\n            }\n        } else {\n            result = str;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate the matcher function against the str arg\n     *\n     * @param {*} matcher - matching function (native or lambda)\n     * @param {string} str - the string to match against\n     * @returns {object} - structure that represents the match(es)\n     */\n    async function evaluateMatcher(matcher, str) {\n        var result = matcher.apply(this, [str]); // eslint-disable-line no-useless-call\n        if(isPromise(result)) {\n            result = await result;\n        }\n        if(result && !(typeof result.start === 'number' || result.end === 'number' || Array.isArray(result.groups) || isFunction(result.next))) {\n            // the matcher function didn't return the correct structure\n            throw {\n                code: \"T1010\",\n                stack: (new Error()).stack,\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Tests if the str contains the token\n     * @param {String} str - string to test\n     * @param {String} token - substring or regex to find\n     * @returns {Boolean} - true if str contains token\n     */\n    async function contains(str, token) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var result;\n\n        if (typeof token === 'string') {\n            result = (str.indexOf(token) !== -1);\n        } else {\n            var matches = await evaluateMatcher(token, str);\n            result = (typeof matches !== 'undefined');\n        }\n\n        return result;\n    }\n\n    /**\n     * Match a string with a regex returning an array of object containing details of each match\n     * @param {String} str - string\n     * @param {String} regex - the regex applied to the string\n     * @param {Integer} [limit] - max number of matches to return\n     * @returns {Array} The array of match objects\n     */\n    async function match(str, regex, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                stack: (new Error()).stack,\n                value: limit,\n                code: 'D3040',\n                index: 3\n            };\n        }\n\n        var result = createSequence();\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            var count = 0;\n            var matches = await evaluateMatcher(regex, str);\n            if (typeof matches !== 'undefined') {\n                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                    result.push({\n                        match: matches.match,\n                        index: matches.start,\n                        groups: matches.groups\n                    });\n                    matches = await evaluateMatcher(matches.next);\n                    count++;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Match a string with a regex returning an array of object containing details of each match\n     * @param {String} str - string\n     * @param {String} pattern - the substring/regex applied to the string\n     * @param {String} replacement - text to replace the matched substrings\n     * @param {Integer} [limit] - max number of matches to return\n     * @returns {Array} The array of match objects\n     */\n    async function replace(str, pattern, replacement, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var self = this;\n\n        // pattern cannot be an empty string\n        if (pattern === '') {\n            throw {\n                code: \"D3010\",\n                stack: (new Error()).stack,\n                value: pattern,\n                index: 2\n            };\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                code: \"D3011\",\n                stack: (new Error()).stack,\n                value: limit,\n                index: 4\n            };\n        }\n\n        var replacer;\n        if (typeof replacement === 'string') {\n            replacer = function (regexMatch) {\n                var substitute = '';\n                // scan forward, copying the replacement text into the substitute string\n                // and replace any occurrence of $n with the values matched by the regex\n                var position = 0;\n                var index = replacement.indexOf('$', position);\n                while (index !== -1 && position < replacement.length) {\n                    substitute += replacement.substring(position, index);\n                    position = index + 1;\n                    var dollarVal = replacement.charAt(position);\n                    if (dollarVal === '$') {\n                        // literal $\n                        substitute += '$';\n                        position++;\n                    } else if (dollarVal === '0') {\n                        substitute += regexMatch.match;\n                        position++;\n                    } else {\n                        var maxDigits;\n                        if (regexMatch.groups.length === 0) {\n                            // no sub-matches; any $ followed by a digit will be replaced by an empty string\n                            maxDigits = 1;\n                        } else {\n                            // max number of digits to parse following the $\n                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;\n                        }\n                        index = parseInt(replacement.substring(position, position + maxDigits), 10);\n                        if (maxDigits > 1 && index > regexMatch.groups.length) {\n                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);\n                        }\n                        if (!isNaN(index)) {\n                            if (regexMatch.groups.length > 0) {\n                                var submatch = regexMatch.groups[index - 1];\n                                if (typeof submatch !== 'undefined') {\n                                    substitute += submatch;\n                                }\n                            }\n                            position += index.toString().length;\n                        } else {\n                            // not a capture group, treat the $ as literal\n                            substitute += '$';\n                        }\n                    }\n                    index = replacement.indexOf('$', position);\n                }\n                substitute += replacement.substring(position);\n                return substitute;\n            };\n        } else {\n            replacer = replacement;\n        }\n\n        var result = '';\n        var position = 0;\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            var count = 0;\n            if (typeof pattern === 'string') {\n                var index = str.indexOf(pattern, position);\n                while (index !== -1 && (typeof limit === 'undefined' || count < limit)) {\n                    result += str.substring(position, index);\n                    result += replacement;\n                    position = index + pattern.length;\n                    count++;\n                    index = str.indexOf(pattern, position);\n                }\n                result += str.substring(position);\n            } else {\n                var matches = await evaluateMatcher(pattern, str);\n                if (typeof matches !== 'undefined') {\n                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                        result += str.substring(position, matches.start);\n                        var replacedWith = replacer.apply(self, [matches]);\n                        if (isPromise(replacedWith)) {\n                            replacedWith = await replacedWith;\n                        }\n                        // check replacedWith is a string\n                        if (typeof replacedWith === 'string') {\n                            result += replacedWith;\n                        } else {\n                            // not a string - throw error\n                            throw {\n                                code: \"D3012\",\n                                stack: (new Error()).stack,\n                                value: replacedWith\n                            };\n                        }\n                        position = matches.start + matches.match.length;\n                        count++;\n                        matches = await evaluateMatcher(matches.next);\n                    }\n                    result += str.substring(position);\n                } else {\n                    result = str;\n                }\n            }\n        } else {\n            result = str;\n        }\n\n        return result;\n    }\n\n    /**\n     * Base64 encode a string\n     * @param {String} str - string\n     * @returns {String} Base 64 encoding of the binary data\n     */\n    function base64encode(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n        // Use btoa in a browser, or Buffer in Node.js\n\n        var btoa = typeof window !== 'undefined' ?\n            /* istanbul ignore next */ window.btoa :\n            function (str) {\n                // Simply doing `new Buffer` at this point causes Browserify to pull\n                // in the entire Buffer browser library, which is large and unnecessary.\n                // Using `global.Buffer` defeats this.\n                return new global.Buffer.from(str, 'binary').toString('base64'); // eslint-disable-line new-cap\n            };\n        return btoa(str);\n    }\n\n    /**\n     * Base64 decode a string\n     * @param {String} str - string\n     * @returns {String} Base 64 encoding of the binary data\n     */\n    function base64decode(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n        // Use btoa in a browser, or Buffer in Node.js\n        var atob = typeof window !== 'undefined' ?\n            /* istanbul ignore next */ window.atob :\n            function (str) {\n                // Simply doing `new Buffer` at this point causes Browserify to pull\n                // in the entire Buffer browser library, which is large and unnecessary.\n                // Using `global.Buffer` defeats this.\n                return new global.Buffer.from(str, 'base64').toString('binary'); // eslint-disable-line new-cap\n            };\n        return atob(str);\n    }\n\n    /**\n     * Encode a string into a component for a url\n     * @param {String} str - String to encode\n     * @returns {string} Encoded string\n     */\n    function encodeUrlComponent(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = encodeURIComponent(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"encodeUrlComponent\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Encode a string into a url\n     * @param {String} str - String to encode\n     * @returns {string} Encoded string\n     */\n    function encodeUrl(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = encodeURI(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"encodeUrl\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Decode a string from a component for a url\n     * @param {String} str - String to decode\n     * @returns {string} Decoded string\n     */\n    function decodeUrlComponent(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = decodeURIComponent(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"decodeUrlComponent\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Decode a string from a url\n     * @param {String} str - String to decode\n     * @returns {string} Decoded string\n     */\n    function decodeUrl(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = decodeURI(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"decodeUrl\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Split a string into an array of substrings\n     * @param {String} str - string\n     * @param {String} separator - the token or regex that splits the string\n     * @param {Integer} [limit] - max number of substrings\n     * @returns {Array} The array of string\n     */\n    async function split(str, separator, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                code: \"D3020\",\n                stack: (new Error()).stack,\n                value: limit,\n                index: 3\n            };\n        }\n\n        var result = [];\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            if (typeof separator === 'string') {\n                result = str.split(separator, limit);\n            } else {\n                var count = 0;\n                var matches = await evaluateMatcher(separator, str);\n                if (typeof matches !== 'undefined') {\n                    var start = 0;\n                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                        result.push(str.substring(start, matches.start));\n                        start = matches.end;\n                        matches = await evaluateMatcher(matches.next);\n                        count++;\n                    }\n                    if (typeof limit === 'undefined' || count < limit) {\n                        result.push(str.substring(start));\n                    }\n                } else {\n                    result.push(str);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Join an array of strings\n     * @param {Array} strs - array of string\n     * @param {String} [separator] - the token that splits the string\n     * @returns {String} The concatenated string\n     */\n    function join(strs, separator) {\n        // undefined inputs always return undefined\n        if (typeof strs === 'undefined') {\n            return undefined;\n        }\n\n        // if separator is not specified, default to empty string\n        if (typeof separator === 'undefined') {\n            separator = \"\";\n        }\n\n        return strs.join(separator);\n    }\n\n    /**\n     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec\n     * @param {number} value - number to format\n     * @param {String} picture - picture string definition\n     * @param {Object} [options] - override locale defaults\n     * @returns {String} The formatted string\n     */\n    function formatNumber(value, picture, options) {\n        // undefined inputs always return undefined\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        var defaults = {\n            \"decimal-separator\": \".\",\n            \"grouping-separator\": \",\",\n            \"exponent-separator\": \"e\",\n            \"infinity\": \"Infinity\",\n            \"minus-sign\": \"-\",\n            \"NaN\": \"NaN\",\n            \"percent\": \"%\",\n            \"per-mille\": \"\\u2030\",\n            \"zero-digit\": \"0\",\n            \"digit\": \"#\",\n            \"pattern-separator\": \";\"\n        };\n\n        // if `options` is specified, then its entries override defaults\n        var properties = defaults;\n        if (typeof options !== 'undefined') {\n            Object.keys(options).forEach(function (key) {\n                properties[key] = options[key];\n            });\n        }\n\n        var decimalDigitFamily = [];\n        var zeroCharCode = properties['zero-digit'].charCodeAt(0);\n        for (var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {\n            decimalDigitFamily.push(String.fromCharCode(ii));\n        }\n\n        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);\n\n        var subPictures = picture.split(properties['pattern-separator']);\n\n        if (subPictures.length > 2) {\n            throw {\n                code: 'D3080',\n                stack: (new Error()).stack\n            };\n        }\n\n        var splitParts = function (subpicture) {\n            var prefix = (function () {\n                var ch;\n                for (var ii = 0; ii < subpicture.length; ii++) {\n                    ch = subpicture.charAt(ii);\n                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {\n                        return subpicture.substring(0, ii);\n                    }\n                }\n            })();\n            var suffix = (function () {\n                var ch;\n                for (var ii = subpicture.length - 1; ii >= 0; ii--) {\n                    ch = subpicture.charAt(ii);\n                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {\n                        return subpicture.substring(ii + 1);\n                    }\n                }\n            })();\n            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);\n            var mantissaPart, exponentPart, integerPart, fractionalPart;\n            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);\n            if (exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {\n                mantissaPart = activePart;\n                exponentPart = undefined;\n            } else {\n                mantissaPart = activePart.substring(0, exponentPosition);\n                exponentPart = activePart.substring(exponentPosition + 1);\n            }\n            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);\n            if (decimalPosition === -1) {\n                integerPart = mantissaPart;\n                fractionalPart = suffix;\n            } else {\n                integerPart = mantissaPart.substring(0, decimalPosition);\n                fractionalPart = mantissaPart.substring(decimalPosition + 1);\n            }\n            return {\n                prefix: prefix,\n                suffix: suffix,\n                activePart: activePart,\n                mantissaPart: mantissaPart,\n                exponentPart: exponentPart,\n                integerPart: integerPart,\n                fractionalPart: fractionalPart,\n                subpicture: subpicture\n            };\n        };\n\n        // validate the picture string, F&O 4.7.3\n        var validate = function (parts) {\n            var error;\n            var ii;\n            var subpicture = parts.subpicture;\n            var decimalPos = subpicture.indexOf(properties['decimal-separator']);\n            if (decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {\n                error = 'D3081';\n            }\n            if (subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {\n                error = 'D3082';\n            }\n            if (subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {\n                error = 'D3083';\n            }\n            if (subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {\n                error = 'D3084';\n            }\n            var valid = false;\n            for (ii = 0; ii < parts.mantissaPart.length; ii++) {\n                var ch = parts.mantissaPart.charAt(ii);\n                if (decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid) {\n                error = 'D3085';\n            }\n            var charTypes = parts.activePart.split('').map(function (char) {\n                return activeChars.indexOf(char) === -1 ? 'p' : 'a';\n            }).join('');\n            if (charTypes.indexOf('p') !== -1) {\n                error = 'D3086';\n            }\n            if (decimalPos !== -1) {\n                if (subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {\n                    error = 'D3087';\n                }\n            } else if (parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {\n                error = 'D3088';\n            }\n            if (subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {\n                error = 'D3089';\n            }\n            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);\n            if (optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) > -1;\n            }).length > 0) {\n                error = 'D3090';\n            }\n            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);\n            if (optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) > -1;\n            }).length > 0) {\n                error = 'D3091';\n            }\n            var exponentExists = (typeof parts.exponentPart === 'string');\n            if (exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {\n                error = 'D3092';\n            }\n            if (exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) === -1;\n            }).length > 0)) {\n                error = 'D3093';\n            }\n            if (error) {\n                throw {\n                    code: error,\n                    stack: (new Error()).stack\n                };\n            }\n        };\n\n        // analyse the picture string, F&O 4.7.4\n        var analyse = function (parts) {\n            var getGroupingPositions = function (part, toLeft) {\n                var positions = [];\n                var groupingPosition = part.indexOf(properties['grouping-separator']);\n                while (groupingPosition !== -1) {\n                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function (char) {\n                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;\n                    }).length;\n                    positions.push(charsToTheRight);\n                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);\n                }\n                return positions;\n            };\n            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);\n            var regular = function (indexes) {\n                // are the grouping positions regular? i.e. same interval between each of them\n                if (indexes.length === 0) {\n                    return 0;\n                }\n                var gcd = function (a, b) {\n                    return b === 0 ? a : gcd(b, a % b);\n                };\n                // find the greatest common divisor of all the positions\n                var factor = indexes.reduce(gcd);\n                // is every position separated by this divisor? If so, it's regular\n                for (var index = 1; index <= indexes.length; index++) {\n                    if (indexes.indexOf(index * factor) === -1) {\n                        return 0;\n                    }\n                }\n                return factor;\n            };\n\n            var regularGrouping = regular(integerPartGroupingPositions);\n            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);\n\n            var minimumIntegerPartSize = parts.integerPart.split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1;\n            }).length;\n            var scalingFactor = minimumIntegerPartSize;\n\n            var fractionalPartArray = parts.fractionalPart.split('');\n            var minimumFactionalPartSize = fractionalPartArray.filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1;\n            }).length;\n            var maximumFactionalPartSize = fractionalPartArray.filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;\n            }).length;\n            var exponentPresent = typeof parts.exponentPart === 'string';\n            if (minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {\n                if (exponentPresent) {\n                    minimumFactionalPartSize = 1;\n                    maximumFactionalPartSize = 1;\n                } else {\n                    minimumIntegerPartSize = 1;\n                }\n            }\n            if (exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {\n                minimumIntegerPartSize = 1;\n            }\n            if (minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {\n                minimumFactionalPartSize = 1;\n            }\n            var minimumExponentSize = 0;\n            if (exponentPresent) {\n                minimumExponentSize = parts.exponentPart.split('').filter(function (char) {\n                    return decimalDigitFamily.indexOf(char) !== -1;\n                }).length;\n            }\n\n            return {\n                integerPartGroupingPositions: integerPartGroupingPositions,\n                regularGrouping: regularGrouping,\n                minimumIntegerPartSize: minimumIntegerPartSize,\n                scalingFactor: scalingFactor,\n                prefix: parts.prefix,\n                fractionalPartGroupingPositions: fractionalPartGroupingPositions,\n                minimumFactionalPartSize: minimumFactionalPartSize,\n                maximumFactionalPartSize: maximumFactionalPartSize,\n                minimumExponentSize: minimumExponentSize,\n                suffix: parts.suffix,\n                picture: parts.subpicture\n            };\n        };\n\n        var parts = subPictures.map(splitParts);\n        parts.forEach(validate);\n\n        var variables = parts.map(analyse);\n\n        var minus_sign = properties['minus-sign'];\n        var zero_digit = properties['zero-digit'];\n        var decimal_separator = properties['decimal-separator'];\n        var grouping_separator = properties['grouping-separator'];\n\n        if (variables.length === 1) {\n            variables.push(JSON.parse(JSON.stringify(variables[0])));\n            variables[1].prefix = minus_sign + variables[1].prefix;\n        }\n\n        // TODO cache the result of the analysis\n\n        // format the number\n        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON\n        var pic;\n        // bullet 2:\n        if (value >= 0) {\n            pic = variables[0];\n        } else {\n            pic = variables[1];\n        }\n        var adjustedNumber;\n        // bullet 3:\n        if (pic.picture.indexOf(properties.percent) !== -1) {\n            adjustedNumber = value * 100;\n        } else if (pic.picture.indexOf(properties['per-mille']) !== -1) {\n            adjustedNumber = value * 1000;\n        } else {\n            adjustedNumber = value;\n        }\n        // bullet 4:\n        // TODO: infinity - not sure we'd ever get this in JSON\n        // bullet 5:\n        var mantissa, exponent;\n        if (pic.minimumExponentSize === 0) {\n            mantissa = adjustedNumber;\n        } else {\n            // mantissa * 10^exponent = adjustedNumber\n            var maxMantissa = Math.pow(10, pic.scalingFactor);\n            var minMantissa = Math.pow(10, pic.scalingFactor - 1);\n            mantissa = adjustedNumber;\n            exponent = 0;\n            while (mantissa < minMantissa) {\n                mantissa *= 10;\n                exponent -= 1;\n            }\n            while (mantissa > maxMantissa) {\n                mantissa /= 10;\n                exponent += 1;\n            }\n        }\n        // bullet 6:\n        var roundedNumber = round(mantissa, pic.maximumFactionalPartSize);\n        // bullet 7:\n        var makeString = function (value, dp) {\n            var str = Math.abs(value).toFixed(dp);\n            if (zero_digit !== '0') {\n                str = str.split('').map(function (digit) {\n                    if (digit >= '0' && digit <= '9') {\n                        return decimalDigitFamily[digit.charCodeAt(0) - 48];\n                    } else {\n                        return digit;\n                    }\n                }).join('');\n            }\n            return str;\n        };\n        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);\n        var decimalPos = stringValue.indexOf('.');\n        if (decimalPos === -1) {\n            stringValue = stringValue + decimal_separator;\n        } else {\n            stringValue = stringValue.replace('.', decimal_separator);\n        }\n        while (stringValue.charAt(0) === zero_digit) {\n            stringValue = stringValue.substring(1);\n        }\n        while (stringValue.charAt(stringValue.length - 1) === zero_digit) {\n            stringValue = stringValue.substring(0, stringValue.length - 1);\n        }\n        // bullets 8 & 9:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        var padLeft = pic.minimumIntegerPartSize - decimalPos;\n        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);\n        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join(zero_digit) : '') + stringValue;\n        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join(zero_digit) : '');\n        decimalPos = stringValue.indexOf(decimal_separator);\n        // bullet 10:\n        if (pic.regularGrouping > 0) {\n            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);\n            for (var group = 1; group <= groupCount; group++) {\n                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), grouping_separator, stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');\n            }\n        } else {\n            pic.integerPartGroupingPositions.forEach(function (pos) {\n                stringValue = [stringValue.slice(0, decimalPos - pos), grouping_separator, stringValue.slice(decimalPos - pos)].join('');\n                decimalPos++;\n            });\n        }\n        // bullet 11:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        pic.fractionalPartGroupingPositions.forEach(function (pos) {\n            stringValue = [stringValue.slice(0, pos + decimalPos + 1), grouping_separator, stringValue.slice(pos + decimalPos + 1)].join('');\n        });\n        // bullet 12:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        if (pic.picture.indexOf(decimal_separator) === -1 || decimalPos === stringValue.length - 1) {\n            stringValue = stringValue.substring(0, stringValue.length - 1);\n        }\n        // bullet 13:\n        if (typeof exponent !== 'undefined') {\n            var stringExponent = makeString(exponent, 0);\n            padLeft = pic.minimumExponentSize - stringExponent.length;\n            if (padLeft > 0) {\n                stringExponent = new Array(padLeft + 1).join(zero_digit) + stringExponent;\n            }\n            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? minus_sign : '') + stringExponent;\n        }\n        // bullet 14:\n        stringValue = pic.prefix + stringValue + pic.suffix;\n        return stringValue;\n    }\n\n    /**\n     * Converts a number to a string using a specified number base\n     * @param {number} value - the number to convert\n     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10\n     * @returns {string} - the converted string\n     */\n    function formatBase(value, radix) {\n        // undefined inputs always return undefined\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        value = round(value);\n\n        if (typeof radix === 'undefined') {\n            radix = 10;\n        } else {\n            radix = round(radix);\n        }\n\n        if (radix < 2 || radix > 36) {\n            throw {\n                code: 'D3100',\n                stack: (new Error()).stack,\n                value: radix\n            };\n\n        }\n\n        var result = value.toString(radix);\n\n        return result;\n    }\n\n    /**\n     * Cast argument to number\n     * @param {Object} arg - Argument\n     * @returns {Number} numeric value of argument\n     */\n    function number(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (typeof arg === 'number') {\n            // already a number\n            result = arg;\n        } else if (typeof arg === 'string' && /^-?[0-9]+(\\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {\n            result = parseFloat(arg);\n        } else if (typeof arg === 'string' && /^(0[xX][0-9A-Fa-f]+)|(0[oO][0-7]+)|(0[bB][0-1]+)$/.test(arg)) {\n            result = Number(arg);\n        } else if (arg === true) {\n            // boolean true casts to 1\n            result = 1;\n        } else if (arg === false) {\n            // boolean false casts to 0\n            result = 0;\n        } else {\n            throw {\n                code: \"D3030\",\n                value: arg,\n                stack: (new Error()).stack,\n                index: 1\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Absolute value of a number\n     * @param {Number} arg - Argument\n     * @returns {Number} absolute value of argument\n     */\n    function abs(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.abs(arg);\n        return result;\n    }\n\n    /**\n     * Rounds a number down to integer\n     * @param {Number} arg - Argument\n     * @returns {Number} rounded integer\n     */\n    function floor(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.floor(arg);\n        return result;\n    }\n\n    /**\n     * Rounds a number up to integer\n     * @param {Number} arg - Argument\n     * @returns {Number} rounded integer\n     */\n    function ceil(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.ceil(arg);\n        return result;\n    }\n\n    /**\n     * Round to half even\n     * @param {Number} arg - Argument\n     * @param {Number} [precision] - number of decimal places\n     * @returns {Number} rounded integer\n     */\n    function round(arg, precision) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (precision) {\n            // shift the decimal place - this needs to be done in a string since multiplying\n            // by a power of ten can introduce floating point precision errors which mess up\n            // this rounding algorithm - See 'Decimal rounding' in\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n            // Shift\n            var value = arg.toString().split('e');\n            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));\n\n        }\n\n        // round up to nearest int\n        result = Math.round(arg);\n        var diff = result - arg;\n        if (Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {\n            // rounded the wrong way - adjust to nearest even number\n            result = result - 1;\n        }\n        if (precision) {\n            // Shift back\n            value = result.toString().split('e');\n            /* istanbul ignore next */\n            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));\n        }\n        if (Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way\n            // JSON doesn't do -0\n            result = 0;\n        }\n        return result;\n    }\n\n    /**\n     * Square root of number\n     * @param {Number} arg - Argument\n     * @returns {Number} square root\n     */\n    function sqrt(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (arg < 0) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3060\",\n                index: 1,\n                value: arg\n            };\n        }\n\n        result = Math.sqrt(arg);\n\n        return result;\n    }\n\n    /**\n     * Raises number to the power of the second number\n     * @param {Number} arg - the base\n     * @param {Number} exp - the exponent\n     * @returns {Number} rounded integer\n     */\n    function power(arg, exp) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.pow(arg, exp);\n\n        if (!isFinite(result)) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3061\",\n                index: 1,\n                value: arg,\n                exp: exp\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns a random number 0 <= n < 1\n     * @returns {number} random number\n     */\n    function random() {\n        return Math.random();\n    }\n\n    /**\n     * Evaluate an input and return a boolean\n     * @param {*} arg - Arguments\n     * @returns {boolean} Boolean\n     */\n    function boolean(arg) {\n        // cast arg to its effective boolean value\n        // boolean: unchanged\n        // string: zero-length -> false; otherwise -> true\n        // number: 0 -> false; otherwise -> true\n        // null -> false\n        // array: empty -> false; length > 1 -> true\n        // object: empty -> false; non-empty -> true\n        // function -> false\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var result = false;\n        if (Array.isArray(arg)) {\n            if (arg.length === 1) {\n                result = boolean(arg[0]);\n            } else if (arg.length > 1) {\n                var trues = arg.filter(function (val) {\n                    return boolean(val);\n                });\n                result = trues.length > 0;\n            }\n        } else if (typeof arg === 'string') {\n            if (arg.length > 0) {\n                result = true;\n            }\n        } else if (isNumeric(arg)) {\n            if (arg !== 0) {\n                result = true;\n            }\n        } else if (arg !== null && typeof arg === 'object') {\n            if (Object.keys(arg).length > 0) {\n                result = true;\n            }\n        } else if (typeof arg === 'boolean' && arg === true) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * returns the Boolean NOT of the arg\n     * @param {*} arg - argument\n     * @returns {boolean} - NOT arg\n     */\n    function not(arg) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        return !boolean(arg);\n    }\n\n    /**\n     * Helper function to build the arguments to be supplied to the function arg of the\n     * HOFs map, filter, each, sift and single\n     * @param {function} func - the function to be invoked\n     * @param {*} arg1 - the first (required) arg - the value\n     * @param {*} arg2 - the second (optional) arg - the position (index or key)\n     * @param {*} arg3 - the third (optional) arg - the whole structure (array or object)\n     * @returns {*[]} the argument list\n     */\n    function hofFuncArgs(func, arg1, arg2, arg3) {\n        var func_args = [arg1]; // the first arg (the value) is required\n        // the other two are optional - only supply it if the function can take it\n        var length = getFunctionArity(func);\n        if (length >= 2) {\n            func_args.push(arg2);\n        }\n        if (length >= 3) {\n            func_args.push(arg3);\n        }\n        return func_args;\n    }\n\n    /**\n     * Create a map from an array of arguments\n     * @param {Array} [arr] - array to map over\n     * @param {Function} func - function to apply\n     * @returns {Array} Map array\n     */\n    async function map(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var result = createSequence();\n        // do the map - iterate over the arrays, and invoke func\n        for (var i = 0; i < arr.length; i++) {\n            var func_args = hofFuncArgs(func, arr[i], i, arr);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (typeof res !== 'undefined') {\n                result.push(res);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a map from an array of arguments\n     * @param {Array} [arr] - array to filter\n     * @param {Function} func - predicate function\n     * @returns {Array} Map array\n     */\n    async function filter(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var result = createSequence();\n\n        for (var i = 0; i < arr.length; i++) {\n            var entry = arr[i];\n            var func_args = hofFuncArgs(func, entry, i, arr);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (boolean(res)) {\n                result.push(entry);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Given an array, find the single element matching a specified condition\n     * Throws an exception if the number of matching elements is not exactly one\n     * @param {Array} [arr] - array to filter\n     * @param {Function} [func] - predicate function\n     * @returns {*} Matching element\n     */\n    async function single(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var hasFoundMatch = false;\n        var result;\n\n        for (var i = 0; i < arr.length; i++) {\n            var entry = arr[i];\n            var positiveResult = true;\n            if (typeof func !== 'undefined') {\n                var func_args = hofFuncArgs(func, entry, i, arr);\n                // invoke func\n                var res = await func.apply(this, func_args);\n                positiveResult = boolean(res);\n            }\n            if (positiveResult) {\n                if(!hasFoundMatch) {\n                    result = entry;\n                    hasFoundMatch = true;\n                } else {\n                    throw {\n                        stack: (new Error()).stack,\n                        code: \"D3138\",\n                        index: i\n                    };\n                }\n            }\n        }\n\n        if(!hasFoundMatch) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3139\"\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Convolves (zips) each value from a set of arrays\n     * @param {Array} [args] - arrays to zip\n     * @returns {Array} Zipped array\n     */\n    function zip() {\n        // this can take a variable number of arguments\n        var result = [];\n        var args = Array.prototype.slice.call(arguments);\n        // length of the shortest array\n        var length = Math.min.apply(Math, args.map(function (arg) {\n            if (Array.isArray(arg)) {\n                return arg.length;\n            }\n            return 0;\n        }));\n        for (var i = 0; i < length; i++) {\n            var tuple = args.map((arg) => {\n                return arg[i];\n            });\n            result.push(tuple);\n        }\n        return result;\n    }\n\n    /**\n     * Fold left function\n     * @param {Array} sequence - Sequence\n     * @param {Function} func - Function\n     * @param {Object} init - Initial value\n     * @returns {*} Result\n     */\n    async function foldLeft(sequence, func, init) {\n        // undefined inputs always return undefined\n        if (typeof sequence === 'undefined') {\n            return undefined;\n        }\n\n        var result;\n\n        var arity = getFunctionArity(func);\n        if (arity < 2) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3050\",\n                index: 1\n            };\n        }\n\n        var index;\n        if (typeof init === 'undefined' && sequence.length > 0) {\n            result = sequence[0];\n            index = 1;\n        } else {\n            result = init;\n            index = 0;\n        }\n\n        while (index < sequence.length) {\n            var args = [result, sequence[index]];\n            if (arity >= 3) {\n                args.push(index);\n            }\n            if (arity >= 4) {\n                args.push(sequence);\n            }\n            result = await func.apply(this, args);\n            index++;\n        }\n\n        return result;\n    }\n\n    /**\n     * Return keys for an object\n     * @param {Object} arg - Object\n     * @returns {Array} Array of keys\n     */\n    function keys(arg) {\n        var result = createSequence();\n\n        if (Array.isArray(arg)) {\n            // merge the keys of all of the items in the array\n            var merge = {};\n            arg.forEach(function (item) {\n                var allkeys = keys(item);\n                allkeys.forEach(function (key) {\n                    merge[key] = true;\n                });\n            });\n            result = keys(merge);\n        } else if (arg !== null && typeof arg === 'object' && !isFunction(arg)) {\n            Object.keys(arg).forEach(key => result.push(key));\n        }\n        return result;\n    }\n\n    /**\n     * Return value from an object for a given key\n     * @param {Object} input - Object/Array\n     * @param {String} key - Key in object\n     * @returns {*} Value of key in object\n     */\n    function lookup(input, key) {\n        // lookup the 'name' item in the input\n        var result;\n        if (Array.isArray(input)) {\n            result = createSequence();\n            for(var ii = 0; ii < input.length; ii++) {\n                var res =  lookup(input[ii], key);\n                if (typeof res !== 'undefined') {\n                    if (Array.isArray(res)) {\n                        res.forEach(val => result.push(val));\n                    } else {\n                        result.push(res);\n                    }\n                }\n            }\n        } else if (input !== null && typeof input === 'object' && !isFunction(input)) {\n            result = input[key];\n        }\n        return result;\n    }\n\n    /**\n     * Append second argument to first\n     * @param {Array|Object} arg1 - First argument\n     * @param {Array|Object} arg2 - Second argument\n     * @returns {*} Appended arguments\n     */\n    function append(arg1, arg2) {\n        // disregard undefined args\n        if (typeof arg1 === 'undefined') {\n            return arg2;\n        }\n        if (typeof arg2 === 'undefined') {\n            return arg1;\n        }\n        // if either argument is not an array, make it so\n        if (!Array.isArray(arg1)) {\n            arg1 = createSequence(arg1);\n        }\n        if (!Array.isArray(arg2)) {\n            arg2 = [arg2];\n        }\n        return arg1.concat(arg2);\n    }\n\n    /**\n     * Determines if the argument is undefined\n     * @param {*} arg - argument\n     * @returns {boolean} False if argument undefined, otherwise true\n     */\n    function exists(arg) {\n        if (typeof arg === 'undefined') {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Splits an object into an array of object with one property each\n     * @param {*} arg - the object to split\n     * @returns {*} - the array\n     */\n    function spread(arg) {\n        var result = createSequence();\n\n        if (Array.isArray(arg)) {\n            // spread all of the items in the array\n            arg.forEach(function (item) {\n                result = append(result, spread(item));\n            });\n        } else if (arg !== null && typeof arg === 'object' && !isLambda(arg)) {\n            for (var key in arg) {\n                var obj = {};\n                obj[key] = arg[key];\n                result.push(obj);\n            }\n        } else {\n            result = arg;\n        }\n        return result;\n    }\n\n    /**\n     * Merges an array of objects into a single object.  Duplicate properties are\n     * overridden by entries later in the array\n     * @param {*} arg - the objects to merge\n     * @returns {*} - the object\n     */\n    function merge(arg) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var result = {};\n\n        arg.forEach(function (obj) {\n            for (var prop in obj) {\n                result[prop] = obj[prop];\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Reverses the order of items in an array\n     * @param {Array} arr - the array to reverse\n     * @returns {Array} - the reversed array\n     */\n    function reverse(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        var length = arr.length;\n        var result = new Array(length);\n        for (var i = 0; i < length; i++) {\n            result[length - i - 1] = arr[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {*} obj - the input object to iterate over\n     * @param {*} func - the function to apply to each key/value pair\n     * @returns {Array} - the resultant array\n     */\n    async function each(obj, func) {\n        var result = createSequence();\n\n        for (var key in obj) {\n            var func_args = hofFuncArgs(func, obj[key], key, obj);\n            // invoke func\n            var val = await func.apply(this, func_args);\n            if(typeof val !== 'undefined') {\n                result.push(val);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {string} [message] - the message to attach to the error\n     * @throws custom error with code 'D3137'\n     */\n    function error(message) {\n        throw {\n            code: \"D3137\",\n            stack: (new Error()).stack,\n            message: message || \"$error() function evaluated\"\n        };\n    }\n\n    /**\n     *\n     * @param {boolean} condition - the condition to evaluate\n     * @param {string} [message] - the message to attach to the error\n     * @throws custom error with code 'D3137'\n     * @returns {undefined}\n     */\n    function assert(condition, message) {\n        if(!condition) {\n            throw {\n                code: \"D3141\",\n                stack: (new Error()).stack,\n                message: message || \"$assert() statement failed\"\n            };\n        }\n\n        return undefined;\n    }\n\n    /**\n     *\n     * @param {*} [value] - the input to which the type will be checked\n     * @returns {string} - the type of the input\n     */\n    function type(value) {\n        if (value === undefined) {\n            return undefined;\n        }\n\n        if (value === null) {\n            return 'null';\n        }\n\n        if (isNumeric(value)) {\n            return 'number';\n        }\n\n        if (typeof value === 'string') {\n            return 'string';\n        }\n\n        if (typeof value === 'boolean') {\n            return 'boolean';\n        }\n\n        if(Array.isArray(value)) {\n            return 'array';\n        }\n\n        if(isFunction(value)) {\n            return 'function';\n        }\n\n        return 'object';\n    }\n\n    /**\n     * Implements the merge sort (stable) with optional comparator function\n     *\n     * @param {Array} arr - the array to sort\n     * @param {*} comparator - comparator function\n     * @returns {Array} - sorted array\n     */\n    async function sort(arr, comparator) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        var comp;\n        if (typeof comparator === 'undefined') {\n            // inject a default comparator - only works for numeric or string arrays\n            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {\n                throw {\n                    stack: (new Error()).stack,\n                    code: \"D3070\",\n                    index: 1\n                };\n            }\n\n            comp = async function (a, b) {\n                return a > b;\n            };\n        } else {\n            // for internal usage of functionSort (i.e. order-by syntax)\n            comp = comparator;\n        }\n\n        var merge = async function (l, r) {\n            var merge_iter = async function (result, left, right) {\n                if (left.length === 0) {\n                    Array.prototype.push.apply(result, right);\n                } else if (right.length === 0) {\n                    Array.prototype.push.apply(result, left);\n                } else if (await comp(left[0], right[0])) { // invoke the comparator function\n                    // if it returns true - swap left and right\n                    result.push(right[0]);\n                    await merge_iter(result, left, right.slice(1));\n                } else {\n                    // otherwise keep the same order\n                    result.push(left[0]);\n                    await merge_iter(result, left.slice(1), right);\n                }\n            };\n            var merged = [];\n            await merge_iter(merged, l, r);\n            return merged;\n        };\n\n        var msort = async function (array) {\n            if (!Array.isArray(array) || array.length <= 1) {\n                return array;\n            } else {\n                var middle = Math.floor(array.length / 2);\n                var left = array.slice(0, middle);\n                var right = array.slice(middle);\n                left = await msort(left);\n                right = await msort(right);\n                return await merge(left, right);\n            }\n        };\n\n        var result = await msort(arr);\n\n        return result;\n    }\n\n    /**\n     * Randomly shuffles the contents of an array\n     * @param {Array} arr - the input array\n     * @returns {Array} the shuffled array\n     */\n    function shuffle(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm\n        var result = new Array(arr.length);\n        for (var i = 0; i < arr.length; i++) {\n            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 ≤ j ≤ i\n            if (i !== j) {\n                result[i] = result[j];\n            }\n            result[j] = arr[i];\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the values that appear in a sequence, with duplicates eliminated.\n     * @param {Array} arr - An array or sequence of values\n     * @returns {Array} - sequence of distinct values\n     */\n    function distinct(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if(!Array.isArray(arr) || arr.length <= 1) {\n            return arr;\n        }\n\n        var results = isSequence(arr) ? createSequence() : [];\n\n        for(var ii = 0; ii < arr.length; ii++) {\n            var value = arr[ii];\n            // is this value already in the result sequence?\n            var includes = false;\n            for(var jj = 0; jj < results.length; jj++) {\n                if (deepEquals(value, results[jj])) {\n                    includes = true;\n                    break;\n                }\n            }\n            if(!includes) {\n                results.push(value);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Applies a predicate function to each key/value pair in an object, and returns an object containing\n     * only the key/value pairs that passed the predicate\n     *\n     * @param {object} arg - the object to be sifted\n     * @param {object} func - the predicate function (lambda or native)\n     * @returns {object} - sifted object\n     */\n    async function sift(arg, func) {\n        var result = {};\n\n        for (var item in arg) {\n            var entry = arg[item];\n            var func_args = hofFuncArgs(func, entry, item, arg);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (boolean(res)) {\n                result[item] = entry;\n            }\n        }\n\n        // empty objects should be changed to undefined\n        if (Object.keys(result).length === 0) {\n            result = undefined;\n        }\n\n        return result;\n    }\n\n    return {\n        sum, count, max, min, average,\n        string, substring, substringBefore, substringAfter, lowercase, uppercase, length, trim, pad,\n        match, contains, replace, split, join,\n        formatNumber, formatBase, number, floor, ceil, round, abs, sqrt, power, random,\n        boolean, not,\n        map, zip, filter, single, foldLeft, sift,\n        keys, lookup, append, exists, spread, merge, reverse, each, error, assert, type, sort, shuffle, distinct,\n        base64encode, base64decode,  encodeUrlComponent, encodeUrl, decodeUrlComponent, decodeUrl\n    };\n})();\n\nmodule.exports = functions;\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./utils\":6}],3:[function(require,module,exports){\n/**\n * © Copyright IBM Corp. 2016, 2017 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\n/**\n * @module JSONata\n * @description JSON query and transformation language\n */\n\nvar datetime = require('./datetime');\nvar fn = require('./functions');\nvar utils = require('./utils');\nvar parser = require('./parser');\nvar parseSignature = require('./signature');\n\n/**\n * jsonata\n * @function\n * @param {Object} expr - JSONata expression\n * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression\n */\nvar jsonata = (function() {\n    'use strict';\n\n    var isNumeric = utils.isNumeric;\n    var isArrayOfStrings = utils.isArrayOfStrings;\n    var isArrayOfNumbers = utils.isArrayOfNumbers;\n    var createSequence = utils.createSequence;\n    var isSequence = utils.isSequence;\n    var isFunction = utils.isFunction;\n    var isLambda = utils.isLambda;\n    var isIterable = utils.isIterable;\n    var isPromise = utils.isPromise;\n    var getFunctionArity = utils.getFunctionArity;\n    var isDeepEqual = utils.isDeepEqual;\n\n    // Start of Evaluator code\n\n    var staticFrame = createFrame(null);\n\n    /**\n     * Evaluate expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluate(expr, input, environment) {\n        var result;\n\n        var entryCallback = environment.lookup(Symbol.for('jsonata.__evaluate_entry'));\n        if(entryCallback) {\n            await entryCallback(expr, input, environment);\n        }\n\n        switch (expr.type) {\n            case 'path':\n                result = await evaluatePath(expr, input, environment);\n                break;\n            case 'binary':\n                result = await evaluateBinary(expr, input, environment);\n                break;\n            case 'unary':\n                result = await evaluateUnary(expr, input, environment);\n                break;\n            case 'name':\n                result = evaluateName(expr, input, environment);\n                break;\n            case 'string':\n            case 'number':\n            case 'value':\n                result = evaluateLiteral(expr, input, environment);\n                break;\n            case 'wildcard':\n                result = evaluateWildcard(expr, input, environment);\n                break;\n            case 'descendant':\n                result = evaluateDescendants(expr, input, environment);\n                break;\n            case 'parent':\n                result = environment.lookup(expr.slot.label);\n                break;\n            case 'condition':\n                result = await evaluateCondition(expr, input, environment);\n                break;\n            case 'block':\n                result = await evaluateBlock(expr, input, environment);\n                break;\n            case 'bind':\n                result = await evaluateBindExpression(expr, input, environment);\n                break;\n            case 'regex':\n                result = evaluateRegex(expr, input, environment);\n                break;\n            case 'function':\n                result = await evaluateFunction(expr, input, environment);\n                break;\n            case 'variable':\n                result = evaluateVariable(expr, input, environment);\n                break;\n            case 'lambda':\n                result = evaluateLambda(expr, input, environment);\n                break;\n            case 'partial':\n                result = await evaluatePartialApplication(expr, input, environment);\n                break;\n            case 'apply':\n                result = await evaluateApplyExpression(expr, input, environment);\n                break;\n            case 'transform':\n                result = evaluateTransformExpression(expr, input, environment);\n                break;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(expr, 'predicate')) {\n            for(var ii = 0; ii < expr.predicate.length; ii++) {\n                result = await evaluateFilter(expr.predicate[ii].expr, result, environment);\n            }\n        }\n\n        if (expr.type !== 'path' && Object.prototype.hasOwnProperty.call(expr, 'group')) {\n            result = await evaluateGroupExpression(expr.group, result, environment);\n        }\n\n        var exitCallback = environment.lookup(Symbol.for('jsonata.__evaluate_exit'));\n        if(exitCallback) {\n            await exitCallback(expr, input, environment, result);\n        }\n\n        if(result && isSequence(result) && !result.tupleStream) {\n            if(expr.keepArray) {\n                result.keepSingleton = true;\n            }\n            if(result.length === 0) {\n                result = undefined;\n            } else if(result.length === 1) {\n                result =  result.keepSingleton ? result : result[0];\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate path expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluatePath(expr, input, environment) {\n        var inputSequence;\n        // expr is an array of steps\n        // if the first step is a variable reference ($...), including root reference ($$),\n        //   then the path is absolute rather than relative\n        if (Array.isArray(input) && expr.steps[0].type !== 'variable') {\n            inputSequence = input;\n        } else {\n            // if input is not an array, make it so\n            inputSequence = createSequence(input);\n        }\n\n        var resultSequence;\n        var isTupleStream = false;\n        var tupleBindings = undefined;\n\n        // evaluate each step in turn\n        for(var ii = 0; ii < expr.steps.length; ii++) {\n            var step = expr.steps[ii];\n\n            if(step.tuple) {\n                isTupleStream = true;\n            }\n\n            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)\n            if(ii === 0 && step.consarray) {\n                resultSequence = await evaluate(step, inputSequence, environment);\n            } else {\n                if(isTupleStream) {\n                    tupleBindings = await evaluateTupleStep(step, inputSequence, tupleBindings, environment);\n                } else {\n                    resultSequence = await evaluateStep(step, inputSequence, environment, ii === expr.steps.length - 1);\n                }\n            }\n\n            if (!isTupleStream && (typeof resultSequence === 'undefined' || resultSequence.length === 0)) {\n                break;\n            }\n\n            if(typeof step.focus === 'undefined') {\n                inputSequence = resultSequence;\n            }\n\n        }\n\n        if(isTupleStream) {\n            if(expr.tuple) {\n                // tuple stream is carrying ancestry information - keep this\n                resultSequence = tupleBindings;\n            } else {\n                resultSequence = createSequence();\n                for (ii = 0; ii < tupleBindings.length; ii++) {\n                    resultSequence.push(tupleBindings[ii]['@']);\n                }\n            }\n        }\n\n        if(expr.keepSingletonArray) {\n            // if the array is explicitly constructed in the expression and marked to promote singleton sequences to array\n            if(Array.isArray(resultSequence) && resultSequence.cons && !resultSequence.sequence) {\n                resultSequence = createSequence(resultSequence);\n            }\n            resultSequence.keepSingleton = true;\n        }\n\n        if (expr.hasOwnProperty('group')) {\n            resultSequence = await evaluateGroupExpression(expr.group, isTupleStream ? tupleBindings : resultSequence, environment)\n        }\n\n        return resultSequence;\n    }\n\n    function createFrameFromTuple(environment, tuple) {\n        var frame = createFrame(environment);\n        for(const prop in tuple) {\n            frame.bind(prop, tuple[prop]);\n        }\n        return frame;\n    }\n\n    /**\n     * Evaluate a step within a path\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @param {boolean} lastStep - flag the last step in a path\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateStep(expr, input, environment, lastStep) {\n        var result;\n        if(expr.type === 'sort') {\n             result = await evaluateSortExpression(expr, input, environment);\n             if(expr.stages) {\n                 result = await evaluateStages(expr.stages, result, environment);\n             }\n             return result;\n        }\n\n        result = createSequence();\n\n        for(var ii = 0; ii < input.length; ii++) {\n            var res = await evaluate(expr, input[ii], environment);\n            if(expr.stages) {\n                for(var ss = 0; ss < expr.stages.length; ss++) {\n                    res = await evaluateFilter(expr.stages[ss].expr, res, environment);\n                }\n            }\n            if(typeof res !== 'undefined') {\n                result.push(res);\n            }\n        }\n\n        var resultSequence = createSequence();\n        if(lastStep && result.length === 1 && Array.isArray(result[0]) && !isSequence(result[0])) {\n            resultSequence = result[0];\n        } else {\n            // flatten the sequence\n            result.forEach(function(res) {\n                if (!Array.isArray(res) || res.cons) {\n                    // it's not an array - just push into the result sequence\n                    resultSequence.push(res);\n                } else {\n                    // res is a sequence - flatten it into the parent sequence\n                    res.forEach(val => resultSequence.push(val));\n                }\n            });\n        }\n\n        return resultSequence;\n    }\n\n    async function evaluateStages(stages, input, environment) {\n        var result = input;\n        for(var ss = 0; ss < stages.length; ss++) {\n            var stage = stages[ss];\n            switch(stage.type) {\n                case 'filter':\n                    result = await evaluateFilter(stage.expr, result, environment);\n                    break;\n                case 'index':\n                    for(var ee = 0; ee < result.length; ee++) {\n                        var tuple = result[ee];\n                        tuple[stage.value] = ee;\n                    }\n                    break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate a step within a path\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} tupleBindings - The tuple stream\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateTupleStep(expr, input, tupleBindings, environment) {\n        var result;\n        if(expr.type === 'sort') {\n            if(tupleBindings) {\n                result = await evaluateSortExpression(expr, tupleBindings, environment);\n            } else {\n                var sorted = await evaluateSortExpression(expr, input, environment);\n                result = createSequence();\n                result.tupleStream = true;\n                for(var ss = 0; ss < sorted.length; ss++) {\n                    var tuple = {'@': sorted[ss]};\n                    tuple[expr.index] = ss;\n                    result.push(tuple);\n                }\n            }\n            if(expr.stages) {\n                result = await evaluateStages(expr.stages, result, environment);\n            }\n            return result;\n        }\n\n        result = createSequence();\n        result.tupleStream = true;\n        var stepEnv = environment;\n        if(tupleBindings === undefined) {\n            tupleBindings = input.map(item => { return {'@': item} });\n        }\n\n        for(var ee = 0; ee < tupleBindings.length; ee++) {\n            stepEnv = createFrameFromTuple(environment, tupleBindings[ee]);\n            var res = await evaluate(expr, tupleBindings[ee]['@'], stepEnv);\n            // res is the binding sequence for the output tuple stream\n            if(typeof res !== 'undefined') {\n                if (!Array.isArray(res)) {\n                    res = [res];\n                }\n                for (var bb = 0; bb < res.length; bb++) {\n                    tuple = {};\n                    Object.assign(tuple, tupleBindings[ee]);\n                    if(res.tupleStream) {\n                        Object.assign(tuple, res[bb]);\n                    } else {\n                        if (expr.focus) {\n                            tuple[expr.focus] = res[bb];\n                            tuple['@'] = tupleBindings[ee]['@'];\n                        } else {\n                            tuple['@'] = res[bb];\n                        }\n                        if (expr.index) {\n                            tuple[expr.index] = bb;\n                        }\n                        if (expr.ancestor) {\n                            tuple[expr.ancestor.label] = tupleBindings[ee]['@'];\n                        }\n                    }\n                    result.push(tuple);\n                }\n            }\n        }\n\n        if(expr.stages) {\n            result = await evaluateStages(expr.stages, result, environment);\n        }\n\n        return result;\n    }\n\n    /**\n     * Apply filter predicate to input data\n     * @param {Object} predicate - filter expression\n     * @param {Object} input - Input data to apply predicates against\n     * @param {Object} environment - Environment\n     * @returns {*} Result after applying predicates\n     */\n    async function evaluateFilter(predicate, input, environment) {\n        var results = createSequence();\n        if( input && input.tupleStream) {\n            results.tupleStream = true;\n        }\n        if (!Array.isArray(input)) {\n            input = createSequence(input);\n        }\n        if (predicate.type === 'number') {\n            var index = Math.floor(predicate.value);  // round it down\n            if (index < 0) {\n                // count in from end of array\n                index = input.length + index;\n            }\n            var item = input[index];\n            if(typeof item !== 'undefined') {\n                if(Array.isArray(item)) {\n                    results = item;\n                } else {\n                    results.push(item);\n                }\n            }\n        } else {\n            for (index = 0; index < input.length; index++) {\n                var item = input[index];\n                var context = item;\n                var env = environment;\n                if(input.tupleStream) {\n                    context = item['@'];\n                    env = createFrameFromTuple(environment, item);\n                }\n                var res = await evaluate(predicate, context, env);\n                if (isNumeric(res)) {\n                    res = [res];\n                }\n                if (isArrayOfNumbers(res)) {\n                    res.forEach(function (ires) {\n                        // round it down\n                        var ii = Math.floor(ires);\n                        if (ii < 0) {\n                            // count in from end of array\n                            ii = input.length + ii;\n                        }\n                        if (ii === index) {\n                            results.push(item);\n                        }\n                    });\n                } else if (fn.boolean(res)) { // truthy\n                    results.push(item);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Evaluate binary expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBinary(expr, input, environment) {\n        var result;\n        var lhs = await evaluate(expr.lhs, input, environment);\n        var op = expr.value;\n\n        //defer evaluation of RHS to allow short-circuiting\n        var evalrhs = async () => await evaluate(expr.rhs, input, environment);\n        if (op === \"and\" || op === \"or\") {\n            try {\n                return await evaluateBooleanExpression(lhs, evalrhs, op);\n            } catch(err) {\n                err.position = expr.position;\n                err.token = op;\n                throw err;\n            }\n        }\n\n        var rhs = await evalrhs();\n        try {\n            switch (op) {\n                case '+':\n                case '-':\n                case '*':\n                case '/':\n                case '%':\n                    result = evaluateNumericExpression(lhs, rhs, op);\n                    break;\n                case '=':\n                case '!=':\n                    result = evaluateEqualityExpression(lhs, rhs, op);\n                    break;\n                case '<':\n                case '<=':\n                case '>':\n                case '>=':\n                    result = evaluateComparisonExpression(lhs, rhs, op);\n                    break;\n                case '&':\n                    result = evaluateStringConcat(lhs, rhs);\n                    break;\n                case '..':\n                    result = evaluateRangeExpression(lhs, rhs);\n                    break;\n                case 'in':\n                    result = evaluateIncludesExpression(lhs, rhs);\n                    break;\n            }\n        } catch(err) {\n            err.position = expr.position;\n            err.token = op;\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate unary expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateUnary(expr, input, environment) {\n        var result;\n\n        switch (expr.value) {\n            case '-':\n                result = await evaluate(expr.expression, input, environment);\n                if(typeof result === 'undefined') {\n                    result = undefined;\n                } else if (isNumeric(result)) {\n                    result = -result;\n                } else {\n                    throw {\n                        code: \"D1002\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        token: expr.value,\n                        value: result\n                    };\n                }\n                break;\n            case '[':\n                // array constructor - evaluate each item\n                result = [];\n                let generators = await Promise.all(expr.expressions\n                    .map(async (item, idx) => {\n                        environment.isParallelCall = idx > 0\n                        return [item, await evaluate(item, input, environment)]\n                    }));\n                for (let generator of generators) {\n                    var [item, value] = generator;\n                    if (typeof value !== 'undefined') {\n                        if(item.value === '[') {\n                            result.push(value);\n                        } else {\n                            result = fn.append(result, value);\n                        }\n                    }\n                }\n                if(expr.consarray) {\n                    Object.defineProperty(result, 'cons', {\n                        enumerable: false,\n                        configurable: false,\n                        value: true\n                    });\n                }\n                break;\n            case '{':\n                // object constructor - apply grouping\n                result = await evaluateGroupExpression(expr, input, environment);\n                break;\n\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate name object against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    function evaluateName(expr, input, environment) {\n        // lookup the 'name' item in the input\n        return fn.lookup(input, expr.value);\n    }\n\n    /**\n     * Evaluate literal against input data\n     * @param {Object} expr - JSONata expression\n     * @returns {*} Evaluated input data\n     */\n    function evaluateLiteral(expr) {\n        return expr.value;\n    }\n\n    /**\n     * Evaluate wildcard against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @returns {*} Evaluated input data\n     */\n    function evaluateWildcard(expr, input) {\n        var results = createSequence();\n        if (Array.isArray(input) && input.outerWrapper && input.length > 0) {\n            input = input[0];\n        }\n        if (input !== null && typeof input === 'object') {\n            Object.keys(input).forEach(function (key) {\n                var value = input[key];\n                if(Array.isArray(value)) {\n                    value = flatten(value);\n                    results = fn.append(results, value);\n                } else {\n                    results.push(value);\n                }\n            });\n        }\n\n        //        result = normalizeSequence(results);\n        return results;\n    }\n\n    /**\n     * Returns a flattened array\n     * @param {Array} arg - the array to be flatten\n     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []\n     * @returns {Array} - the flattened array\n     */\n    function flatten(arg, flattened) {\n        if(typeof flattened === 'undefined') {\n            flattened = [];\n        }\n        if(Array.isArray(arg)) {\n            arg.forEach(function (item) {\n                flatten(item, flattened);\n            });\n        } else {\n            flattened.push(arg);\n        }\n        return flattened;\n    }\n\n    /**\n     * Evaluate descendants against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @returns {*} Evaluated input data\n     */\n    function evaluateDescendants(expr, input) {\n        var result;\n        var resultSequence = createSequence();\n        if (typeof input !== 'undefined') {\n            // traverse all descendants of this object/array\n            recurseDescendants(input, resultSequence);\n            if (resultSequence.length === 1) {\n                result = resultSequence[0];\n            } else {\n                result = resultSequence;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Recurse through descendants\n     * @param {Object} input - Input data\n     * @param {Object} results - Results\n     */\n    function recurseDescendants(input, results) {\n        // this is the equivalent of //* in XPath\n        if (!Array.isArray(input)) {\n            results.push(input);\n        }\n        if (Array.isArray(input)) {\n            input.forEach(function (member) {\n                recurseDescendants(member, results);\n            });\n        } else if (input !== null && typeof input === 'object') {\n            Object.keys(input).forEach(function (key) {\n                recurseDescendants(input[key], results);\n            });\n        }\n    }\n\n    /**\n     * Evaluate numeric expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateNumericExpression(lhs, rhs, op) {\n        var result;\n\n        if (typeof lhs !== 'undefined' && !isNumeric(lhs)) {\n            throw {\n                code: \"T2001\",\n                stack: (new Error()).stack,\n                value: lhs\n            };\n        }\n        if (typeof rhs !== 'undefined' && !isNumeric(rhs)) {\n            throw {\n                code: \"T2002\",\n                stack: (new Error()).stack,\n                value: rhs\n            };\n        }\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is undefined\n            return result;\n        }\n\n        switch (op) {\n            case '+':\n                result = lhs + rhs;\n                break;\n            case '-':\n                result = lhs - rhs;\n                break;\n            case '*':\n                result = lhs * rhs;\n                break;\n            case '/':\n                result = lhs / rhs;\n                break;\n            case '%':\n                result = lhs % rhs;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate equality expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateEqualityExpression(lhs, rhs, op) {\n        var result;\n\n        // type checks\n        var ltype = typeof lhs;\n        var rtype = typeof rhs;\n\n        if (ltype === 'undefined' || rtype === 'undefined') {\n            // if either side is undefined, the result is false\n            return false;\n        }\n\n        switch (op) {\n            case '=':\n                result = isDeepEqual(lhs, rhs);\n                break;\n            case '!=':\n                result = !isDeepEqual(lhs, rhs);\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate comparison expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateComparisonExpression(lhs, rhs, op) {\n        var result;\n\n        // type checks\n        var ltype = typeof lhs;\n        var rtype = typeof rhs;\n\n        var lcomparable = (ltype === 'undefined' || ltype === 'string' || ltype === 'number');\n        var rcomparable = (rtype === 'undefined' || rtype === 'string' || rtype === 'number');\n\n        // if either aa or bb are not comparable (string or numeric) values, then throw an error\n        if (!lcomparable || !rcomparable) {\n            throw {\n                code: \"T2010\",\n                stack: (new Error()).stack,\n                value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs\n            };\n        }\n\n        // if either side is undefined, the result is undefined\n        if (ltype === 'undefined' || rtype === 'undefined') {\n            return undefined;\n        }\n\n        //if aa and bb are not of the same type\n        if (ltype !== rtype) {\n            throw {\n                code: \"T2009\",\n                stack: (new Error()).stack,\n                value: lhs,\n                value2: rhs\n            };\n        }\n\n        switch (op) {\n            case '<':\n                result = lhs < rhs;\n                break;\n            case '<=':\n                result = lhs <= rhs;\n                break;\n            case '>':\n                result = lhs > rhs;\n                break;\n            case '>=':\n                result = lhs >= rhs;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Inclusion operator - in\n     *\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {boolean} - true if lhs is a member of rhs\n     */\n    function evaluateIncludesExpression(lhs, rhs) {\n        var result = false;\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is false\n            return false;\n        }\n\n        if(!Array.isArray(rhs)) {\n            rhs = [rhs];\n        }\n\n        for(var i = 0; i < rhs.length; i++) {\n            if(rhs[i] === lhs) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate boolean expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Function} evalrhs - function to evaluate RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    async function evaluateBooleanExpression(lhs, evalrhs, op) {\n        var result;\n\n        var lBool = boolize(lhs);\n\n        switch (op) {\n            case 'and':\n                result = lBool && boolize(await evalrhs());\n                break;\n            case 'or':\n                result = lBool || boolize(await evalrhs());\n                break;\n        }\n        return result;\n    }\n\n    function boolize(value) {\n        var booledValue = fn.boolean(value);\n        return typeof booledValue === 'undefined' ? false : booledValue;\n    }\n\n    /**\n     * Evaluate string concatenation against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {string|*} Concatenated string\n     */\n    function evaluateStringConcat(lhs, rhs) {\n        var result;\n\n        var lstr = '';\n        var rstr = '';\n        if (typeof lhs !== 'undefined') {\n            lstr = fn.string(lhs);\n        }\n        if (typeof rhs !== 'undefined') {\n            rstr = fn.string(rhs);\n        }\n\n        result = lstr.concat(rstr);\n        return result;\n    }\n\n    /**\n     * Evaluate group expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {{}} Evaluated input data\n     */\n    async function evaluateGroupExpression(expr, input, environment) {\n        var result = {};\n        var groups = {};\n        var reduce = input && input.tupleStream ? true : false;\n        // group the input sequence by 'key' expression\n        if (!Array.isArray(input)) {\n            input = createSequence(input);\n        }\n        // if the array is empty, add an undefined entry to enable literal JSON object to be generated\n        if (input.length === 0) {\n            input.push(undefined);\n        }\n\n        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {\n            var item = input[itemIndex];\n            var env = reduce ? createFrameFromTuple(environment, item) : environment;\n            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {\n                var pair = expr.lhs[pairIndex];\n                var key = await evaluate(pair[0], reduce ? item['@'] : item, env);\n                // key has to be a string\n                if (typeof  key !== 'string' && key !== undefined) {\n                    throw {\n                        code: \"T1003\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: key\n                    };\n                }\n\n                if (key !== undefined) {\n                    var entry = {data: item, exprIndex: pairIndex};\n                    if (groups.hasOwnProperty(key)) {\n                        // a value already exists in this slot\n                        if(groups[key].exprIndex !== pairIndex) {\n                            // this key has been generated by another expression in this group\n                            // when multiple key expressions evaluate to the same key, then error D1009 must be thrown\n                            throw {\n                                code: \"D1009\",\n                                stack: (new Error()).stack,\n                                position: expr.position,\n                                value: key\n                            };\n                        }\n\n                        // append it as an array\n                        groups[key].data = fn.append(groups[key].data, item);\n                    } else {\n                        groups[key] = entry;\n                    }\n                }\n            }\n        }\n\n        // iterate over the groups to evaluate the 'value' expression\n        let generators = await Promise.all(Object.keys(groups).map(async (key, idx) => {\n            let entry = groups[key];\n            var context = entry.data;\n            var env = environment;\n            if (reduce) {\n                var tuple = reduceTupleStream(entry.data);\n                context = tuple['@'];\n                delete tuple['@'];\n                env = createFrameFromTuple(environment, tuple);\n            }\n            environment.isParallelCall = idx > 0\n            return [key, await evaluate(expr.lhs[entry.exprIndex][1], context, env)];\n        }));\n\n        for (let generator of generators) {\n            var [key, value] = await generator;\n            if(typeof value !== 'undefined') {\n                result[key] = value;\n            }\n        }\n\n        return result;\n    }\n\n    function reduceTupleStream(tupleStream) {\n        if(!Array.isArray(tupleStream)) {\n            return tupleStream;\n        }\n        var result = {};\n        Object.assign(result, tupleStream[0]);\n        for(var ii = 1; ii < tupleStream.length; ii++) {\n            for(const prop in tupleStream[ii]) {\n                result[prop] = fn.append(result[prop], tupleStream[ii][prop]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate range expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {Array} Resultant array\n     */\n    function evaluateRangeExpression(lhs, rhs) {\n        var result;\n\n        if (typeof lhs !== 'undefined' && !Number.isInteger(lhs)) {\n            throw {\n                code: \"T2003\",\n                stack: (new Error()).stack,\n                value: lhs\n            };\n        }\n        if (typeof rhs !== 'undefined' && !Number.isInteger(rhs)) {\n            throw {\n                code: \"T2004\",\n                stack: (new Error()).stack,\n                value: rhs\n            };\n        }\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is undefined\n            return result;\n        }\n\n        if (lhs > rhs) {\n            // if the lhs is greater than the rhs, return undefined\n            return result;\n        }\n\n        // limit the size of the array to ten million entries (1e7)\n        // this is an implementation defined limit to protect against\n        // memory and performance issues.  This value may increase in the future.\n        var size = rhs - lhs + 1;\n        if(size > 1e7) {\n            throw {\n                code: \"D2014\",\n                stack: (new Error()).stack,\n                value: size\n            };\n        }\n\n        result = new Array(size);\n        for (var item = lhs, index = 0; item <= rhs; item++, index++) {\n            result[index] = item;\n        }\n        result.sequence = true;\n        return result;\n    }\n\n    /**\n     * Evaluate bind expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBindExpression(expr, input, environment) {\n        // The RHS is the expression to evaluate\n        // The LHS is the name of the variable to bind to - should be a VARIABLE token (enforced by parser)\n        var value = await evaluate(expr.rhs, input, environment);\n        environment.bind(expr.lhs.value, value);\n        return value;\n    }\n\n    /**\n     * Evaluate condition against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateCondition(expr, input, environment) {\n        var result;\n        var condition = await evaluate(expr.condition, input, environment);\n        if (fn.boolean(condition)) {\n            result = await evaluate(expr.then, input, environment);\n        } else if (typeof expr.else !== 'undefined') {\n            result = await evaluate(expr.else, input, environment);\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate block against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBlock(expr, input, environment) {\n        var result;\n        // create a new frame to limit the scope of variable assignments\n        // TODO, only do this if the post-parse stage has flagged this as required\n        var frame = createFrame(environment);\n        // invoke each expression in turn\n        // only return the result of the last one\n        for(var ii = 0; ii < expr.expressions.length; ii++) {\n            result = await evaluate(expr.expressions[ii], input, frame);\n        }\n\n        return result;\n    }\n\n    /**\n     * Prepare a regex\n     * @param {Object} expr - expression containing regex\n     * @returns {Function} Higher order function representing prepared regex\n     */\n    function evaluateRegex(expr) {\n        var re = new jsonata.RegexEngine(expr.value);\n        var closure = function(str, fromIndex) {\n            var result;\n            re.lastIndex = fromIndex || 0;\n            var match = re.exec(str);\n            if(match !== null) {\n                result = {\n                    match: match[0],\n                    start: match.index,\n                    end: match.index + match[0].length,\n                    groups: []\n                };\n                if(match.length > 1) {\n                    for(var i = 1; i < match.length; i++) {\n                        result.groups.push(match[i]);\n                    }\n                }\n                result.next = function() {\n                    if(re.lastIndex >= str.length) {\n                        return undefined;\n                    } else {\n                        var next = closure(str, re.lastIndex);\n                        if(next && next.match === '') {\n                            // matches zero length string; this will never progress\n                            throw {\n                                code: \"D1004\",\n                                stack: (new Error()).stack,\n                                position: expr.position,\n                                value: expr.value.source\n                            };\n                        }\n                        return next;\n                    }\n                };\n            }\n\n            return result;\n        };\n        return closure;\n    }\n\n    /**\n     * Evaluate variable against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    function evaluateVariable(expr, input, environment) {\n        // lookup the variable value in the environment\n        var result;\n        // if the variable name is empty string, then it refers to context value\n        if (expr.value === '') {\n            result = input && input.outerWrapper ? input[0] : input;\n        } else {\n            result = environment.lookup(expr.value);\n        }\n        return result;\n    }\n\n    /**\n     * sort / order-by operator\n     * @param {Object} expr - AST for operator\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Ordered sequence\n     */\n    async function evaluateSortExpression(expr, input, environment) {\n        var result;\n\n        // evaluate the lhs, then sort the results in order according to rhs expression\n        var lhs = input;\n        var isTupleSort = input.tupleStream ? true : false;\n\n        // sort the lhs array\n        // use comparator function\n        var comparator = async function(a, b) { \n            // expr.terms is an array of order-by in priority order\n            var comp = 0;\n            for(var index = 0; comp === 0 && index < expr.terms.length; index++) {\n                var term = expr.terms[index];\n                //evaluate the sort term in the context of a\n                var context = a;\n                var env = environment;\n                if(isTupleSort) {\n                    context = a['@'];\n                    env = createFrameFromTuple(environment, a);\n                }\n                var aa = await evaluate(term.expression, context, env);\n                //evaluate the sort term in the context of b\n                context = b;\n                env = environment;\n                if(isTupleSort) {\n                    context = b['@'];\n                    env = createFrameFromTuple(environment, b);\n                }\n                var bb = await evaluate(term.expression, context, env);\n\n                // type checks\n                var atype = typeof aa;\n                var btype = typeof bb;\n                // undefined should be last in sort order\n                if(atype === 'undefined') {\n                    // swap them, unless btype is also undefined\n                    comp = (btype === 'undefined') ? 0 : 1;\n                    continue;\n                }\n                if(btype === 'undefined') {\n                    comp = -1;\n                    continue;\n                }\n\n                // if aa or bb are not string or numeric values, then throw an error\n                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {\n                    throw {\n                        code: \"T2008\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: !(atype === 'string' || atype === 'number') ? aa : bb\n                    };\n                }\n\n                //if aa and bb are not of the same type\n                if(atype !== btype) {\n                    throw {\n                        code: \"T2007\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: aa,\n                        value2: bb\n                    };\n                }\n                if(aa === bb) {\n                    // both the same - move on to next term\n                    continue;\n                } else if (aa < bb) {\n                    comp = -1;\n                } else {\n                    comp = 1;\n                }\n                if(term.descending === true) {\n                    comp = -comp;\n                }\n            }\n            // only swap a & b if comp equals 1\n            return comp === 1;\n        };\n\n        var focus = {\n            environment: environment,\n            input: input\n        };\n        // the `focus` is passed in as the `this` for the invoked function\n        result = await fn.sort.apply(focus, [lhs, comparator]);\n\n        return result;\n    }\n\n    /**\n     * create a transformer function\n     * @param {Object} expr - AST for operator\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} tranformer function\n     */\n    function evaluateTransformExpression(expr, input, environment) {\n        // create a function to implement the transform definition\n        var transformer = async function (obj) { // signature <(oa):o>\n            // undefined inputs always return undefined\n            if(typeof obj === 'undefined') {\n                return undefined;\n            }\n\n            // this function returns a copy of obj with changes specified by the pattern/operation\n            var cloneFunction = environment.lookup('clone');\n            if(!isFunction(cloneFunction)) {\n                // throw type error\n                throw {\n                    code: \"T2013\",\n                    stack: (new Error()).stack,\n                    position: expr.position\n                };\n            }\n            var result = await apply(cloneFunction, [obj], null, environment);\n            var matches = await evaluate(expr.pattern, result, environment);\n            if(typeof matches !== 'undefined') {\n                if(!Array.isArray(matches)) {\n                    matches = [matches];\n                }\n                for(var ii = 0; ii < matches.length; ii++) {\n                    var match = matches[ii];\n                    if (match && (match.isPrototypeOf(result) || match instanceof Object.constructor)) {\n                        throw {\n                            code: \"D1010\",\n                            stack: (new Error()).stack,\n                            position: expr.position\n                        };\n                    }\n                    // evaluate the update value for each match\n                    var update = await evaluate(expr.update, match, environment);\n                    // update must be an object\n                    var updateType = typeof update;\n                    if(updateType !== 'undefined') {\n                        if(updateType !== 'object' || update === null || Array.isArray(update)) {\n                            // throw type error\n                            throw {\n                                code: \"T2011\",\n                                stack: (new Error()).stack,\n                                position: expr.update.position,\n                                value: update\n                            };\n                        }\n                        // merge the update\n                        for(var prop in update) {\n                            match[prop] = update[prop];\n                        }\n                    }\n\n                    // delete, if specified, must be an array of strings (or single string)\n                    if(typeof expr.delete !== 'undefined') {\n                        var deletions = await evaluate(expr.delete, match, environment);\n                        if(typeof deletions !== 'undefined') {\n                            var val = deletions;\n                            if (!Array.isArray(deletions)) {\n                                deletions = [deletions];\n                            }\n                            if (!isArrayOfStrings(deletions)) {\n                                // throw type error\n                                throw {\n                                    code: \"T2012\",\n                                    stack: (new Error()).stack,\n                                    position: expr.delete.position,\n                                    value: val\n                                };\n                            }\n                            for (var jj = 0; jj < deletions.length; jj++) {\n                                if(typeof match === 'object' && match !== null) {\n                                    delete match[deletions[jj]];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        return defineFunction(transformer, '<(oa):o>');\n    }\n\n    var chainAST = parser('function($f, $g) { function($x){ $g($f($x)) } }');\n\n    /**\n     * Apply the function on the RHS using the sequence on the LHS as the first argument\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateApplyExpression(expr, input, environment) {\n        var result;\n\n\n        var lhs = await evaluate(expr.lhs, input, environment);\n        if(expr.rhs.type === 'function') {\n            // this is a function _invocation_; invoke it with lhs expression as the first argument\n            result = await evaluateFunction(expr.rhs, input, environment, { context: lhs });\n        } else {\n            var func = await evaluate(expr.rhs, input, environment);\n\n            if(!isFunction(func)) {\n                throw {\n                    code: \"T2006\",\n                    stack: (new Error()).stack,\n                    position: expr.position,\n                    value: func\n                };\n            }\n\n            if(isFunction(lhs)) {\n                // this is function chaining (func1 ~> func2)\n                // λ($f, $g) { λ($x){ $g($f($x)) } }\n                var chain = await evaluate(chainAST, null, environment);\n                result = await apply(chain, [lhs, func], null, environment);\n            } else {\n                result = await apply(func, [lhs], null, environment);\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate function against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateFunction(expr, input, environment, applyto) {\n        var result;\n\n        // create the procedure\n        // can't assume that expr.procedure is a lambda type directly\n        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.\n        // evaluate it generically first, then check that it is a function.  Throw error if not.\n        var proc = await evaluate(expr.procedure, input, environment);\n\n        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {\n            // help the user out here if they simply forgot the leading $\n            throw {\n                code: \"T1005\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.steps[0].value\n            };\n        }\n\n        var evaluatedArgs = [];\n        if(typeof applyto !== 'undefined') {\n            evaluatedArgs.push(applyto.context);\n        }\n        // eager evaluation - evaluate the arguments\n        for (var jj = 0; jj < expr.arguments.length; jj++) {\n            const arg = await evaluate(expr.arguments[jj], input, environment);\n            if(isFunction(arg)) {\n                // wrap this in a closure\n                const closure = async function (...params) {\n                    // invoke func\n                    return await apply(arg, params, null, environment);\n                };\n                closure.arity = getFunctionArity(arg);\n                evaluatedArgs.push(closure);\n            } else {\n                evaluatedArgs.push(arg);\n            }\n        }\n        // apply the procedure\n        var procName = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;\n        try {\n            if(typeof proc === 'object') {\n                proc.token = procName;\n                proc.position = expr.position;\n            }\n            result = await apply(proc, evaluatedArgs, input, environment);\n        } catch (err) {\n            if(!err.position) {\n                // add the position field to the error\n                err.position = expr.position;\n            }\n            if (!err.token) {\n                // and the function identifier\n                err.token = procName;\n            }\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Apply procedure or function\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @param {Object} input - input\n     * @param {Object} environment - environment\n     * @returns {*} Result of procedure\n     */\n    async function apply(proc, args, input, environment) {\n        var result;\n        result = await applyInner(proc, args, input, environment);\n        while(isLambda(result) && result.thunk === true) {\n            // trampoline loop - this gets invoked as a result of tail-call optimization\n            // the function returned a tail-call thunk\n            // unpack it, evaluate its arguments, and apply the tail call\n            var next = await evaluate(result.body.procedure, result.input, result.environment);\n            if(result.body.procedure.type === 'variable') {\n                next.token = result.body.procedure.value;\n            }\n            next.position = result.body.procedure.position;\n            var evaluatedArgs = [];\n            for(var ii = 0; ii < result.body.arguments.length; ii++) {\n                evaluatedArgs.push(await evaluate(result.body.arguments[ii], result.input, result.environment));\n            }\n\n            result = await applyInner(next, evaluatedArgs, input, environment);\n        }\n        return result;\n    }\n\n    /**\n     * Apply procedure or function\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @param {Object} input - input\n     * @param {Object} environment - environment\n     * @returns {*} Result of procedure\n     */\n    async function applyInner(proc, args, input, environment) {\n        var result;\n        try {\n            var validatedArgs = args;\n            if (proc) {\n                validatedArgs = validateArguments(proc.signature, args, input);\n            }\n\n            if (isLambda(proc)) {\n                result = await applyProcedure(proc, validatedArgs);\n            } else if (proc && proc._jsonata_function === true) {\n                var focus = {\n                    environment: environment,\n                    input: input\n                };\n                // the `focus` is passed in as the `this` for the invoked function\n                result = proc.implementation.apply(focus, validatedArgs);\n                // `proc.implementation` might be a generator function\n                // and `result` might be a generator - if so, yield\n                if (isIterable(result)) {\n                    result = result.next().value;\n                }\n                if (isPromise(result)) {\n                    result = await result;\n                }\n            } else if (typeof proc === 'function') {\n                // typically these are functions that are returned by the invocation of plugin functions\n                // the `input` is being passed in as the `this` for the invoked function\n                // this is so that functions that return objects containing functions can chain\n                // e.g. await (await $func())\n                result = proc.apply(input, validatedArgs);\n                if (isPromise(result)) {\n                    result = await result;\n                }\n            } else {\n                throw {\n                    code: \"T1006\",\n                    stack: (new Error()).stack\n                };\n            }\n        } catch(err) {\n            if(proc) {\n                if (typeof err.token == 'undefined' && typeof proc.token !== 'undefined') {\n                    err.token = proc.token;\n                }\n                err.position = proc.position || err.position;\n            }\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate lambda against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data\n     */\n    function evaluateLambda(expr, input, environment) {\n        // make a function (closure)\n        var procedure = {\n            _jsonata_lambda: true,\n            input: input,\n            environment: environment,\n            arguments: expr.arguments,\n            signature: expr.signature,\n            body: expr.body\n        };\n        if(expr.thunk === true) {\n            procedure.thunk = true;\n        }\n        procedure.apply = async function(self, args) {\n            return await apply(procedure, args, input, !!self ? self.environment : environment);\n        };\n        return procedure;\n    }\n\n    /**\n     * Evaluate partial application\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluatePartialApplication(expr, input, environment) {\n        // partially apply a function\n        var result;\n        // evaluate the arguments\n        var evaluatedArgs = [];\n        for(var ii = 0; ii < expr.arguments.length; ii++) {\n            var arg = expr.arguments[ii];\n            if (arg.type === 'operator' && arg.value === '?') {\n                evaluatedArgs.push(arg);\n            } else {\n                evaluatedArgs.push(await evaluate(arg, input, environment));\n            }\n        }\n        // lookup the procedure\n        var proc = await evaluate(expr.procedure, input, environment);\n        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {\n            // help the user out here if they simply forgot the leading $\n            throw {\n                code: \"T1007\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.steps[0].value\n            };\n        }\n        if (isLambda(proc)) {\n            result = partialApplyProcedure(proc, evaluatedArgs);\n        } else if (proc && proc._jsonata_function === true) {\n            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);\n        } else if (typeof proc === 'function') {\n            result = partialApplyNativeFunction(proc, evaluatedArgs);\n        } else {\n            throw {\n                code: \"T1008\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Validate the arguments against the signature validator (if it exists)\n     * @param {Function} signature - validator function\n     * @param {Array} args - function arguments\n     * @param {*} context - context value\n     * @returns {Array} - validated arguments\n     */\n    function validateArguments(signature, args, context) {\n        if(typeof signature === 'undefined') {\n            // nothing to validate\n            return args;\n        }\n        var validatedArgs = signature.validate(args, context);\n        return validatedArgs;\n    }\n\n    /**\n     * Apply procedure\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @returns {*} Result of procedure\n     */\n    async function applyProcedure(proc, args) {\n        var result;\n        var env = createFrame(proc.environment);\n        proc.arguments.forEach(function (param, index) {\n            env.bind(param.value, args[index]);\n        });\n        if (typeof proc.body === 'function') {\n            // this is a lambda that wraps a native function - generated by partially evaluating a native\n            result = await applyNativeFunction(proc.body, env);\n        } else {\n            result = await evaluate(proc.body, proc.input, env);\n        }\n        return result;\n    }\n\n    /**\n     * Partially apply procedure\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure\n     */\n    function partialApplyProcedure(proc, args) {\n        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters\n        var env = createFrame(proc.environment);\n        var unboundArgs = [];\n        proc.arguments.forEach(function (param, index) {\n            var arg = args[index];\n            if (arg && arg.type === 'operator' && arg.value === '?') {\n                unboundArgs.push(param);\n            } else {\n                env.bind(param.value, arg);\n            }\n        });\n        var procedure = {\n            _jsonata_lambda: true,\n            input: proc.input,\n            environment: env,\n            arguments: unboundArgs,\n            body: proc.body\n        };\n        return procedure;\n    }\n\n    /**\n     * Partially apply native function\n     * @param {Function} native - Native function\n     * @param {Array} args - Arguments\n     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function\n     */\n    function partialApplyNativeFunction(native, args) {\n        // create a lambda function that wraps and invokes the native function\n        // get the list of declared arguments from the native function\n        // this has to be picked out from the toString() value\n        var sigArgs = getNativeFunctionArguments(native);\n        sigArgs = sigArgs.map(function (sigArg) {\n            return '$' + sigArg.trim();\n        });\n        var body = 'function(' + sigArgs.join(', ') + '){ _ }';\n\n        var bodyAST = parser(body);\n        bodyAST.body = native;\n\n        var partial = partialApplyProcedure(bodyAST, args);\n        return partial;\n    }\n\n    /**\n     * Apply native function\n     * @param {Object} proc - Procedure\n     * @param {Object} env - Environment\n     * @returns {*} Result of applying native function\n     */\n    async function applyNativeFunction(proc, env) {\n        var sigArgs = getNativeFunctionArguments(proc);\n        // generate the array of arguments for invoking the function - look them up in the environment\n        var args = sigArgs.map(function (sigArg) {\n            return env.lookup(sigArg.trim());\n        });\n\n        var focus = {\n            environment: env\n        };\n        var result = proc.apply(focus, args);\n        if (isPromise(result)) {\n            result = await result;\n        }\n        return result;\n    }\n\n    /**\n     * Get native function arguments\n     * @param {Function} func - Function\n     * @returns {*|Array} Native function arguments\n     */\n    function getNativeFunctionArguments(func) {\n        var signature = func.toString();\n        var sigParens = /\\(([^)]*)\\)/.exec(signature)[1]; // the contents of the parens\n        var sigArgs = sigParens.split(',');\n        return sigArgs;\n    }\n\n    /**\n     * Creates a function definition\n     * @param {Function} func - function implementation in Javascript\n     * @param {string} signature - JSONata function signature definition\n     * @returns {{implementation: *, signature: *}} function definition\n     */\n    function defineFunction(func, signature) {\n        var definition = {\n            _jsonata_function: true,\n            implementation: func\n        };\n        if(typeof signature !== 'undefined') {\n            definition.signature = parseSignature(signature);\n        }\n        return definition;\n    }\n\n\n    /**\n     * parses and evaluates the supplied expression\n     * @param {string} expr - expression to evaluate\n     * @returns {*} - result of evaluating the expression\n     */\n    async function functionEval(expr, focus) {\n        // undefined inputs always return undefined\n        if(typeof expr === 'undefined') {\n            return undefined;\n        }\n        var input = this.input;\n        if(typeof focus !== 'undefined') {\n            input = focus;\n            // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input\n            if(Array.isArray(input) && !isSequence(input)) {\n                input = createSequence(input);\n                input.outerWrapper = true;\n            }\n        }\n\n        try {\n            var ast = parser(expr, false);\n        } catch(err) {\n            // error parsing the expression passed to $eval\n            populateMessage(err);\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3120\",\n                value: err.message,\n                error: err\n            };\n        }\n        try {\n            var result = await evaluate(ast, input, this.environment);\n        } catch(err) {\n            // error evaluating the expression passed to $eval\n            populateMessage(err);\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3121\",\n                value:err.message,\n                error: err\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Clones an object\n     * @param {Object} arg - object to clone (deep copy)\n     * @returns {*} - the cloned object\n     */\n    function functionClone(arg) {\n        // undefined inputs always return undefined\n        if(typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        return JSON.parse(fn.string(arg));\n    }\n\n    /**\n     * Create frame\n     * @param {Object} enclosingEnvironment - Enclosing environment\n     * @returns {{bind: bind, lookup: lookup}} Created frame\n     */\n    function createFrame(enclosingEnvironment) {\n        var bindings = {};\n        const newFrame = {\n            bind: function (name, value) {\n                bindings[name] = value;\n            },\n            lookup: function (name) {\n                var value;\n                if(bindings.hasOwnProperty(name)) {\n                    value = bindings[name];\n                } else if (enclosingEnvironment) {\n                    value = enclosingEnvironment.lookup(name);\n                }\n                return value;\n            },\n            timestamp: enclosingEnvironment ? enclosingEnvironment.timestamp : null,\n            async: enclosingEnvironment ? enclosingEnvironment.async : false,\n            isParallelCall: enclosingEnvironment ? enclosingEnvironment.isParallelCall : false,\n            global: enclosingEnvironment ? enclosingEnvironment.global : {\n                ancestry: [ null ]\n            }\n        };\n\n        if (enclosingEnvironment) {\n            var framePushCallback = enclosingEnvironment.lookup(Symbol.for('jsonata.__createFrame_push'));\n            if(framePushCallback) {\n                framePushCallback(enclosingEnvironment, newFrame);\n            }\n        }\n       \n\n        return newFrame\n    }\n\n    // Function registration\n    staticFrame.bind('sum', defineFunction(fn.sum, '<a<n>:n>'));\n    staticFrame.bind('count', defineFunction(fn.count, '<a:n>'));\n    staticFrame.bind('max', defineFunction(fn.max, '<a<n>:n>'));\n    staticFrame.bind('min', defineFunction(fn.min, '<a<n>:n>'));\n    staticFrame.bind('average', defineFunction(fn.average, '<a<n>:n>'));\n    staticFrame.bind('string', defineFunction(fn.string, '<x-b?:s>'));\n    staticFrame.bind('substring', defineFunction(fn.substring, '<s-nn?:s>'));\n    staticFrame.bind('substringBefore', defineFunction(fn.substringBefore, '<s-s:s>'));\n    staticFrame.bind('substringAfter', defineFunction(fn.substringAfter, '<s-s:s>'));\n    staticFrame.bind('lowercase', defineFunction(fn.lowercase, '<s-:s>'));\n    staticFrame.bind('uppercase', defineFunction(fn.uppercase, '<s-:s>'));\n    staticFrame.bind('length', defineFunction(fn.length, '<s-:n>'));\n    staticFrame.bind('trim', defineFunction(fn.trim, '<s-:s>'));\n    staticFrame.bind('pad', defineFunction(fn.pad, '<s-ns?:s>'));\n    staticFrame.bind('match', defineFunction(fn.match, '<s-f<s:o>n?:a<o>>'));\n    staticFrame.bind('contains', defineFunction(fn.contains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>\n    staticFrame.bind('replace', defineFunction(fn.replace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>\n    staticFrame.bind('split', defineFunction(fn.split, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>\n    staticFrame.bind('join', defineFunction(fn.join, '<a<s>s?:s>'));\n    staticFrame.bind('formatNumber', defineFunction(fn.formatNumber, '<n-so?:s>'));\n    staticFrame.bind('formatBase', defineFunction(fn.formatBase, '<n-n?:s>'));\n    staticFrame.bind('formatInteger', defineFunction(datetime.formatInteger, '<n-s:s>'));\n    staticFrame.bind('parseInteger', defineFunction(datetime.parseInteger, '<s-s:n>'));\n    staticFrame.bind('number', defineFunction(fn.number, '<(nsb)-:n>'));\n    staticFrame.bind('floor', defineFunction(fn.floor, '<n-:n>'));\n    staticFrame.bind('ceil', defineFunction(fn.ceil, '<n-:n>'));\n    staticFrame.bind('round', defineFunction(fn.round, '<n-n?:n>'));\n    staticFrame.bind('abs', defineFunction(fn.abs, '<n-:n>'));\n    staticFrame.bind('sqrt', defineFunction(fn.sqrt, '<n-:n>'));\n    staticFrame.bind('power', defineFunction(fn.power, '<n-n:n>'));\n    staticFrame.bind('random', defineFunction(fn.random, '<:n>'));\n    staticFrame.bind('boolean', defineFunction(fn.boolean, '<x-:b>'));\n    staticFrame.bind('not', defineFunction(fn.not, '<x-:b>'));\n    staticFrame.bind('map', defineFunction(fn.map, '<af>'));\n    staticFrame.bind('zip', defineFunction(fn.zip, '<a+>'));\n    staticFrame.bind('filter', defineFunction(fn.filter, '<af>'));\n    staticFrame.bind('single', defineFunction(fn.single, '<af?>'));\n    staticFrame.bind('reduce', defineFunction(fn.foldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>\n    staticFrame.bind('sift', defineFunction(fn.sift, '<o-f?:o>'));\n    staticFrame.bind('keys', defineFunction(fn.keys, '<x-:a<s>>'));\n    staticFrame.bind('lookup', defineFunction(fn.lookup, '<x-s:x>'));\n    staticFrame.bind('append', defineFunction(fn.append, '<xx:a>'));\n    staticFrame.bind('exists', defineFunction(fn.exists, '<x:b>'));\n    staticFrame.bind('spread', defineFunction(fn.spread, '<x-:a<o>>'));\n    staticFrame.bind('merge', defineFunction(fn.merge, '<a<o>:o>'));\n    staticFrame.bind('reverse', defineFunction(fn.reverse, '<a:a>'));\n    staticFrame.bind('each', defineFunction(fn.each, '<o-f:a>'));\n    staticFrame.bind('error', defineFunction(fn.error, '<s?:x>'));\n    staticFrame.bind('assert', defineFunction(fn.assert, '<bs?:x>'));\n    staticFrame.bind('type', defineFunction(fn.type, '<x:s>'));\n    staticFrame.bind('sort', defineFunction(fn.sort, '<af?:a>'));\n    staticFrame.bind('shuffle', defineFunction(fn.shuffle, '<a:a>'));\n    staticFrame.bind('distinct', defineFunction(fn.distinct, '<x:x>'));\n    staticFrame.bind('base64encode', defineFunction(fn.base64encode, '<s-:s>'));\n    staticFrame.bind('base64decode', defineFunction(fn.base64decode, '<s-:s>'));\n    staticFrame.bind('encodeUrlComponent', defineFunction(fn.encodeUrlComponent, '<s-:s>'));\n    staticFrame.bind('encodeUrl', defineFunction(fn.encodeUrl, '<s-:s>'));\n    staticFrame.bind('decodeUrlComponent', defineFunction(fn.decodeUrlComponent, '<s-:s>'));\n    staticFrame.bind('decodeUrl', defineFunction(fn.decodeUrl, '<s-:s>'));\n    staticFrame.bind('eval', defineFunction(functionEval, '<sx?:x>'));\n    staticFrame.bind('toMillis', defineFunction(datetime.toMillis, '<s-s?:n>'));\n    staticFrame.bind('fromMillis', defineFunction(datetime.fromMillis, '<n-s?s?:s>'));\n    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));\n\n    /**\n     * Error codes\n     *\n     * Sxxxx    - Static errors (compile time)\n     * Txxxx    - Type errors\n     * Dxxxx    - Dynamic errors (evaluate time)\n     *  01xx    - tokenizer\n     *  02xx    - parser\n     *  03xx    - regex parser\n     *  04xx    - function signature parser/evaluator\n     *  10xx    - evaluator\n     *  20xx    - operators\n     *  3xxx    - functions (blocks of 10 for each function)\n     */\n    var errorCodes = {\n        \"S0101\": \"String literal must be terminated by a matching quote\",\n        \"S0102\": \"Number out of range: {{token}}\",\n        \"S0103\": \"Unsupported escape sequence: \\\\{{token}}\",\n        \"S0104\": \"The escape sequence \\\\u must be followed by 4 hex digits\",\n        \"S0105\": \"Quoted property name must be terminated with a backquote (`)\",\n        \"S0106\": \"Comment has no closing tag\",\n        \"S0201\": \"Syntax error: {{token}}\",\n        \"S0202\": \"Expected {{value}}, got {{token}}\",\n        \"S0203\": \"Expected {{value}} before end of expression\",\n        \"S0204\": \"Unknown operator: {{token}}\",\n        \"S0205\": \"Unexpected token: {{token}}\",\n        \"S0206\": \"Unknown expression type: {{token}}\",\n        \"S0207\": \"Unexpected end of expression\",\n        \"S0208\": \"Parameter {{value}} of function definition must be a variable name (start with $)\",\n        \"S0209\": \"A predicate cannot follow a grouping expression in a step\",\n        \"S0210\": \"Each step can only have one grouping expression\",\n        \"S0211\": \"The symbol {{token}} cannot be used as a unary operator\",\n        \"S0212\": \"The left side of := must be a variable name (start with $)\",\n        \"S0213\": \"The literal value {{value}} cannot be used as a step within a path expression\",\n        \"S0214\": \"The right side of {{token}} must be a variable name (start with $)\",\n        \"S0215\": \"A context variable binding must precede any predicates on a step\",\n        \"S0216\": \"A context variable binding must precede the 'order-by' clause on a step\",\n        \"S0217\": \"The object representing the 'parent' cannot be derived from this expression\",\n        \"S0301\": \"Empty regular expressions are not allowed\",\n        \"S0302\": \"No terminating / in regular expression\",\n        \"S0402\": \"Choice groups containing parameterized types are not supported\",\n        \"S0401\": \"Type parameters can only be applied to functions and arrays\",\n        \"S0500\": \"Attempted to evaluate an expression containing syntax error(s)\",\n        \"T0410\": \"Argument {{index}} of function {{token}} does not match function signature\",\n        \"T0411\": \"Context value is not a compatible type with argument {{index}} of function {{token}}\",\n        \"T0412\": \"Argument {{index}} of function {{token}} must be an array of {{type}}\",\n        \"D1001\": \"Number out of range: {{value}}\",\n        \"D1002\": \"Cannot negate a non-numeric value: {{value}}\",\n        \"T1003\": \"Key in object structure must evaluate to a string; got: {{value}}\",\n        \"D1004\": \"Regular expression matches zero length string\",\n        \"T1005\": \"Attempted to invoke a non-function. Did you mean ${{{token}}}?\",\n        \"T1006\": \"Attempted to invoke a non-function\",\n        \"T1007\": \"Attempted to partially apply a non-function. Did you mean ${{{token}}}?\",\n        \"T1008\": \"Attempted to partially apply a non-function\",\n        \"D1009\": \"Multiple key definitions evaluate to same key: {{value}}\",\n        \"D1010\": \"Attempted to access the Javascript object prototype\", // Javascript specific \n        \"T1010\": \"The matcher function argument passed to function {{token}} does not return the correct object structure\",\n        \"T2001\": \"The left side of the {{token}} operator must evaluate to a number\",\n        \"T2002\": \"The right side of the {{token}} operator must evaluate to a number\",\n        \"T2003\": \"The left side of the range operator (..) must evaluate to an integer\",\n        \"T2004\": \"The right side of the range operator (..) must evaluate to an integer\",\n        \"D2005\": \"The left side of := must be a variable name (start with $)\",  // defunct - replaced by S0212 parser error\n        \"T2006\": \"The right side of the function application operator ~> must be a function\",\n        \"T2007\": \"Type mismatch when comparing values {{value}} and {{value2}} in order-by clause\",\n        \"T2008\": \"The expressions within an order-by clause must evaluate to numeric or string values\",\n        \"T2009\": \"The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type\",\n        \"T2010\": \"The expressions either side of operator {{token}} must evaluate to numeric or string values\",\n        \"T2011\": \"The insert/update clause of the transform expression must evaluate to an object: {{value}}\",\n        \"T2012\": \"The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}\",\n        \"T2013\": \"The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.\",\n        \"D2014\": \"The size of the sequence allocated by the range operator (..) must not exceed 1e6.  Attempted to allocate {{value}}.\",\n        \"D3001\": \"Attempting to invoke string function on Infinity or NaN\",\n        \"D3010\": \"Second argument of replace function cannot be an empty string\",\n        \"D3011\": \"Fourth argument of replace function must evaluate to a positive number\",\n        \"D3012\": \"Attempted to replace a matched string with a non-string value\",\n        \"D3020\": \"Third argument of split function must evaluate to a positive number\",\n        \"D3030\": \"Unable to cast value to a number: {{value}}\",\n        \"D3040\": \"Third argument of match function must evaluate to a positive number\",\n        \"D3050\": \"The second argument of reduce function must be a function with at least two arguments\",\n        \"D3060\": \"The sqrt function cannot be applied to a negative number: {{value}}\",\n        \"D3061\": \"The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}\",\n        \"D3070\": \"The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function\",\n        \"D3080\": \"The picture string must only contain a maximum of two sub-pictures\",\n        \"D3081\": \"The sub-picture must not contain more than one instance of the 'decimal-separator' character\",\n        \"D3082\": \"The sub-picture must not contain more than one instance of the 'percent' character\",\n        \"D3083\": \"The sub-picture must not contain more than one instance of the 'per-mille' character\",\n        \"D3084\": \"The sub-picture must not contain both a 'percent' and a 'per-mille' character\",\n        \"D3085\": \"The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'\",\n        \"D3086\": \"The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character\",\n        \"D3087\": \"The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character\",\n        \"D3088\": \"The sub-picture must not contain a 'grouping-separator' at the end of the integer part\",\n        \"D3089\": \"The sub-picture must not contain two adjacent instances of the 'grouping-separator' character\",\n        \"D3090\": \"The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'\",\n        \"D3091\": \"The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'\",\n        \"D3092\": \"A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'\",\n        \"D3093\": \"The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'\",\n        \"D3100\": \"The radix of the formatBase function must be between 2 and 36.  It was given {{value}}\",\n        \"D3110\": \"The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}\",\n        \"D3120\": \"Syntax error in expression passed to function eval: {{value}}\",\n        \"D3121\": \"Dynamic error evaluating the expression passed to function eval: {{value}}\",\n        \"D3130\": \"Formatting or parsing an integer as a sequence starting with {{value}} is not supported by this implementation\",\n        \"D3131\": \"In a decimal digit pattern, all digits must be from the same decimal group\",\n        \"D3132\": \"Unknown component specifier {{value}} in date/time picture string\",\n        \"D3133\": \"The 'name' modifier can only be applied to months and days in the date/time picture string, not {{value}}\",\n        \"D3134\": \"The timezone integer format specifier cannot have more than four digits\",\n        \"D3135\": \"No matching closing bracket ']' in date/time picture string\",\n        \"D3136\": \"The date/time picture string is missing specifiers required to parse the timestamp\",\n        \"D3137\": \"{{{message}}}\",\n        \"D3138\": \"The $single() function expected exactly 1 matching result.  Instead it matched more.\",\n        \"D3139\": \"The $single() function expected exactly 1 matching result.  Instead it matched 0.\",\n        \"D3140\": \"Malformed URL passed to ${{{functionName}}}(): {{value}}\",\n        \"D3141\": \"{{{message}}}\"\n    };\n\n    /**\n     * lookup a message template from the catalog and substitute the inserts.\n     * Populates `err.message` with the substituted message. Leaves `err.message`\n     * untouched if code lookup fails.\n     * @param {string} err - error code to lookup\n     * @returns {undefined} - `err` is modified in place\n     */\n    function populateMessage(err) {\n        var template = errorCodes[err.code];\n        if(typeof template !== 'undefined') {\n            // if there are any handlebars, replace them with the field references\n            // triple braces - replace with value\n            // double braces - replace with json stringified value\n            var message = template.replace(/\\{\\{\\{([^}]+)}}}/g, function() {\n                return err[arguments[1]];\n            });\n            message = message.replace(/\\{\\{([^}]+)}}/g, function() {\n                return JSON.stringify(err[arguments[1]]);\n            });\n            err.message = message;\n        }\n        // Otherwise retain the original `err.message`\n    }\n\n    /**\n     * JSONata\n     * @param {Object} expr - JSONata expression\n     * @param {Object} options\n     * @param {boolean} options.recover: attempt to recover on parse error\n     * @param {Function} options.RegexEngine: RegEx class constructor to use\n     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression\n     */\n    function jsonata(expr, options) {\n        var ast;\n        var errors;\n        try {\n            ast = parser(expr, options && options.recover);\n            errors = ast.errors;\n            delete ast.errors;\n        } catch(err) {\n            // insert error message into structure\n            populateMessage(err); // possible side-effects on `err`\n            throw err;\n        }\n        var environment = createFrame(staticFrame);\n\n        var timestamp = new Date(); // will be overridden on each call to evalute()\n        environment.bind('now', defineFunction(function(picture, timezone) {\n            return datetime.fromMillis(timestamp.getTime(), picture, timezone);\n        }, '<s?s?:s>'));\n        environment.bind('millis', defineFunction(function() {\n            return timestamp.getTime();\n        }, '<:n>'));\n\n        if(options && options.RegexEngine) {\n            jsonata.RegexEngine = options.RegexEngine;\n        } else {\n            jsonata.RegexEngine = RegExp;\n        }\n\n        return {\n            evaluate: async function (input, bindings, callback) {\n                // throw if the expression compiled with syntax errors\n                if(typeof errors !== 'undefined') {\n                    var err = {\n                        code: 'S0500',\n                        position: 0\n                    };\n                    populateMessage(err); // possible side-effects on `err`\n                    throw err;\n                }\n\n                if (typeof bindings !== 'undefined') {\n                    var exec_env;\n                    // the variable bindings have been passed in - create a frame to hold these\n                    exec_env = createFrame(environment);\n                    for (var v in bindings) {\n                        exec_env.bind(v, bindings[v]);\n                    }\n                } else {\n                    exec_env = environment;\n                }\n                // put the input document into the environment as the root object\n                exec_env.bind('$', input);\n\n                // capture the timestamp and put it in the execution environment\n                // the $now() and $millis() functions will return this value - whenever it is called\n                timestamp = new Date();\n                exec_env.timestamp = timestamp;\n\n                // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input\n                if(Array.isArray(input) && !isSequence(input)) {\n                    input = createSequence(input);\n                    input.outerWrapper = true;\n                }\n\n                var it;\n                try {\n                    it = await evaluate(ast, input, exec_env);\n                    if (typeof callback === \"function\") {\n                        callback(null, it);\n                    }\n                    return it;\n                } catch (err) {\n                    // insert error message into structure\n                    populateMessage(err); // possible side-effects on `err`\n                    throw err;\n                }\n            },\n            assign: function (name, value) {\n                environment.bind(name, value);\n            },\n            registerFunction: function(name, implementation, signature) {\n                var func = defineFunction(implementation, signature);\n                environment.bind(name, func);\n            },\n            ast: function() {\n                return ast;\n            },\n            errors: function() {\n                return errors;\n            }\n        };\n    }\n\n    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead\n\n    return jsonata;\n\n})();\n\nmodule.exports = jsonata;\n\n},{\"./datetime\":1,\"./functions\":2,\"./parser\":4,\"./signature\":5,\"./utils\":6}],4:[function(require,module,exports){\n/**\n * © Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar parseSignature = require('./signature');\n\nconst parser = (() => {\n    'use strict';\n\n    var operators = {\n        '.': 75,\n        '[': 80,\n        ']': 0,\n        '{': 70,\n        '}': 0,\n        '(': 80,\n        ')': 0,\n        ',': 0,\n        '@': 80,\n        '#': 80,\n        ';': 80,\n        ':': 80,\n        '?': 20,\n        '+': 50,\n        '-': 50,\n        '*': 60,\n        '/': 60,\n        '%': 60,\n        '|': 20,\n        '=': 40,\n        '<': 40,\n        '>': 40,\n        '^': 40,\n        '**': 60,\n        '..': 20,\n        ':=': 10,\n        '!=': 40,\n        '<=': 40,\n        '>=': 40,\n        '~>': 40,\n        'and': 30,\n        'or': 25,\n        'in': 40,\n        '&': 50,\n        '!': 0,   // not an operator, but needed as a stop character for name tokens\n        '~': 0   // not an operator, but needed as a stop character for name tokens\n    };\n\n    var escapes = {  // JSON string escape sequences - see json.org\n        '\"': '\"',\n        '\\\\': '\\\\',\n        '/': '/',\n        'b': '\\b',\n        'f': '\\f',\n        'n': '\\n',\n        'r': '\\r',\n        't': '\\t'\n    };\n\n    // Tokenizer (lexer) - invoked by the parser to return one token at a time\n    var tokenizer = function (path) {\n        var position = 0;\n        var length = path.length;\n\n        var create = function (type, value) {\n            var obj = {type: type, value: value, position: position};\n            return obj;\n        };\n\n        var scanRegex = function () {\n            // the prefix '/' will have been previously scanned. Find the end of the regex.\n            // search for closing '/' ignoring any that are escaped, or within brackets\n            var start = position;\n            var depth = 0;\n            var pattern;\n            var flags;\n\n            var isClosingSlash = function (position) {\n                if (path.charAt(position) === '/' && depth === 0) {\n                    var backslashCount = 0;\n                    while (path.charAt(position - (backslashCount + 1)) === '\\\\') {\n                        backslashCount++;\n                    }\n                    if (backslashCount % 2 === 0) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n            while (position < length) {\n                var currentChar = path.charAt(position);\n                if (isClosingSlash(position)) {\n                    // end of regex found\n                    pattern = path.substring(start, position);\n                    if (pattern === '') {\n                        throw {\n                            code: \"S0301\",\n                            stack: (new Error()).stack,\n                            position: position\n                        };\n                    }\n                    position++;\n                    currentChar = path.charAt(position);\n                    // flags\n                    start = position;\n                    while (currentChar === 'i' || currentChar === 'm') {\n                        position++;\n                        currentChar = path.charAt(position);\n                    }\n                    flags = path.substring(start, position) + 'g';\n                    return new RegExp(pattern, flags);\n                }\n                if ((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\\\') {\n                    depth++;\n                }\n                if ((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\\\') {\n                    depth--;\n                }\n\n                position++;\n            }\n            throw {\n                code: \"S0302\",\n                stack: (new Error()).stack,\n                position: position\n            };\n        };\n\n        var next = function (prefix) {\n            if (position >= length) return null;\n            var currentChar = path.charAt(position);\n            // skip whitespace\n            while (position < length && ' \\t\\n\\r\\v'.indexOf(currentChar) > -1) {\n                position++;\n                currentChar = path.charAt(position);\n            }\n            // skip comments\n            if (currentChar === '/' && path.charAt(position + 1) === '*') {\n                var commentStart = position;\n                position += 2;\n                currentChar = path.charAt(position);\n                while (!(currentChar === '*' && path.charAt(position + 1) === '/')) {\n                    currentChar = path.charAt(++position);\n                    if (position >= length) {\n                        // no closing tag\n                        throw {\n                            code: \"S0106\",\n                            stack: (new Error()).stack,\n                            position: commentStart\n                        };\n                    }\n                }\n                position += 2;\n                currentChar = path.charAt(position);\n                return next(prefix); // need this to swallow any following whitespace\n            }\n            // test for regex\n            if (prefix !== true && currentChar === '/') {\n                position++;\n                return create('regex', scanRegex());\n            }\n            // handle double-char operators\n            if (currentChar === '.' && path.charAt(position + 1) === '.') {\n                // double-dot .. range operator\n                position += 2;\n                return create('operator', '..');\n            }\n            if (currentChar === ':' && path.charAt(position + 1) === '=') {\n                // := assignment\n                position += 2;\n                return create('operator', ':=');\n            }\n            if (currentChar === '!' && path.charAt(position + 1) === '=') {\n                // !=\n                position += 2;\n                return create('operator', '!=');\n            }\n            if (currentChar === '>' && path.charAt(position + 1) === '=') {\n                // >=\n                position += 2;\n                return create('operator', '>=');\n            }\n            if (currentChar === '<' && path.charAt(position + 1) === '=') {\n                // <=\n                position += 2;\n                return create('operator', '<=');\n            }\n            if (currentChar === '*' && path.charAt(position + 1) === '*') {\n                // **  descendant wildcard\n                position += 2;\n                return create('operator', '**');\n            }\n            if (currentChar === '~' && path.charAt(position + 1) === '>') {\n                // ~>  chain function\n                position += 2;\n                return create('operator', '~>');\n            }\n            // test for single char operators\n            if (Object.prototype.hasOwnProperty.call(operators, currentChar)) {\n                position++;\n                return create('operator', currentChar);\n            }\n            // test for string literals\n            if (currentChar === '\"' || currentChar === \"'\") {\n                var quoteType = currentChar;\n                // double quoted string literal - find end of string\n                position++;\n                var qstr = \"\";\n                while (position < length) {\n                    currentChar = path.charAt(position);\n                    if (currentChar === '\\\\') { // escape sequence\n                        position++;\n                        currentChar = path.charAt(position);\n                        if (Object.prototype.hasOwnProperty.call(escapes, currentChar)) {\n                            qstr += escapes[currentChar];\n                        } else if (currentChar === 'u') {\n                            // \\u should be followed by 4 hex digits\n                            var octets = path.substr(position + 1, 4);\n                            if (/^[0-9a-fA-F]+$/.test(octets)) {\n                                var codepoint = parseInt(octets, 16);\n                                qstr += String.fromCharCode(codepoint);\n                                position += 4;\n                            } else {\n                                throw {\n                                    code: \"S0104\",\n                                    stack: (new Error()).stack,\n                                    position: position\n                                };\n                            }\n                        } else {\n                            // illegal escape sequence\n                            throw {\n                                code: \"S0103\",\n                                stack: (new Error()).stack,\n                                position: position,\n                                token: currentChar\n                            };\n\n                        }\n                    } else if (currentChar === quoteType) {\n                        position++;\n                        return create('string', qstr);\n                    } else {\n                        qstr += currentChar;\n                    }\n                    position++;\n                }\n                throw {\n                    code: \"S0101\",\n                    stack: (new Error()).stack,\n                    position: position\n                };\n            }\n            // test for numbers\n            var numregex = /^-?(0|([1-9][0-9]*))(\\.[0-9]+)?([Ee][-+]?[0-9]+)?/;\n            var match = numregex.exec(path.substring(position));\n            if (match !== null) {\n                var num = parseFloat(match[0]);\n                if (!isNaN(num) && isFinite(num)) {\n                    position += match[0].length;\n                    return create('number', num);\n                } else {\n                    throw {\n                        code: \"S0102\",\n                        stack: (new Error()).stack,\n                        position: position,\n                        token: match[0]\n                    };\n                }\n            }\n            // test for quoted names (backticks)\n            var name;\n            if (currentChar === '`') {\n                // scan for closing quote\n                position++;\n                var end = path.indexOf('`', position);\n                if (end !== -1) {\n                    name = path.substring(position, end);\n                    position = end + 1;\n                    return create('name', name);\n                }\n                position = length;\n                throw {\n                    code: \"S0105\",\n                    stack: (new Error()).stack,\n                    position: position\n                };\n            }\n            // test for names\n            var i = position;\n            var ch;\n            for (; ;) {\n                ch = path.charAt(i);\n                if (i === length || ' \\t\\n\\r\\v'.indexOf(ch) > -1 || Object.prototype.hasOwnProperty.call(operators, ch)) {\n                    if (path.charAt(position) === '$') {\n                        // variable reference\n                        name = path.substring(position + 1, i);\n                        position = i;\n                        return create('variable', name);\n                    } else {\n                        name = path.substring(position, i);\n                        position = i;\n                        switch (name) {\n                            case 'or':\n                            case 'in':\n                            case 'and':\n                                return create('operator', name);\n                            case 'true':\n                                return create('value', true);\n                            case 'false':\n                                return create('value', false);\n                            case 'null':\n                                return create('value', null);\n                            default:\n                                if (position === length && name === '') {\n                                    // whitespace at end of input\n                                    return null;\n                                }\n                                return create('name', name);\n                        }\n                    }\n                } else {\n                    i++;\n                }\n            }\n        };\n\n        return next;\n    };\n\n    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.\n    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html\n    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6\n\n    var parser = function (source, recover) {\n        var node;\n        var lexer;\n\n        var symbol_table = {};\n        var errors = [];\n\n        var remainingTokens = function () {\n            var remaining = [];\n            if (node.id !== '(end)') {\n                remaining.push({type: node.type, value: node.value, position: node.position});\n            }\n            var nxt = lexer();\n            while (nxt !== null) {\n                remaining.push(nxt);\n                nxt = lexer();\n            }\n            return remaining;\n        };\n\n        var base_symbol = {\n            nud: function () {\n                // error - symbol has been invoked as a unary operator\n                var err = {\n                    code: 'S0211',\n                    token: this.value,\n                    position: this.position\n                };\n\n                if (recover) {\n                    err.remaining = remainingTokens();\n                    err.type = 'error';\n                    errors.push(err);\n                    return err;\n                } else {\n                    err.stack = (new Error()).stack;\n                    throw err;\n                }\n            }\n        };\n\n        var symbol = function (id, bp) {\n            var s = symbol_table[id];\n            bp = bp || 0;\n            if (s) {\n                if (bp >= s.lbp) {\n                    s.lbp = bp;\n                }\n            } else {\n                s = Object.create(base_symbol);\n                s.id = s.value = id;\n                s.lbp = bp;\n                symbol_table[id] = s;\n            }\n            return s;\n        };\n\n        var handleError = function (err) {\n            if (recover) {\n                // tokenize the rest of the buffer and add it to an error token\n                err.remaining = remainingTokens();\n                errors.push(err);\n                var symbol = symbol_table[\"(error)\"];\n                node = Object.create(symbol);\n                node.error = err;\n                node.type = \"(error)\";\n                return node;\n            } else {\n                err.stack = (new Error()).stack;\n                throw err;\n            }\n        };\n\n        var advance = function (id, infix) {\n            if (id && node.id !== id) {\n                var code;\n                if (node.id === '(end)') {\n                    // unexpected end of buffer\n                    code = \"S0203\";\n                } else {\n                    code = \"S0202\";\n                }\n                var err = {\n                    code: code,\n                    position: node.position,\n                    token: node.value,\n                    value: id\n                };\n                return handleError(err);\n            }\n            var next_token = lexer(infix);\n            if (next_token === null) {\n                node = symbol_table[\"(end)\"];\n                node.position = source.length;\n                return node;\n            }\n            var value = next_token.value;\n            var type = next_token.type;\n            var symbol;\n            switch (type) {\n                case 'name':\n                case 'variable':\n                    symbol = symbol_table[\"(name)\"];\n                    break;\n                case 'operator':\n                    symbol = symbol_table[value];\n                    if (!symbol) {\n                        return handleError({\n                            code: \"S0204\",\n                            stack: (new Error()).stack,\n                            position: next_token.position,\n                            token: value\n                        });\n                    }\n                    break;\n                case 'string':\n                case 'number':\n                case 'value':\n                    symbol = symbol_table[\"(literal)\"];\n                    break;\n                case 'regex':\n                    type = \"regex\";\n                    symbol = symbol_table[\"(regex)\"];\n                    break;\n                /* istanbul ignore next */\n                default:\n                    return handleError({\n                        code: \"S0205\",\n                        stack: (new Error()).stack,\n                        position: next_token.position,\n                        token: value\n                    });\n            }\n\n            node = Object.create(symbol);\n            node.value = value;\n            node.type = type;\n            node.position = next_token.position;\n            return node;\n        };\n\n        // Pratt's algorithm\n        var expression = function (rbp) {\n            var left;\n            var t = node;\n            advance(null, true);\n            left = t.nud();\n            while (rbp < node.lbp) {\n                t = node;\n                advance();\n                left = t.led(left);\n            }\n            return left;\n        };\n\n        var terminal = function (id) {\n            var s = symbol(id, 0);\n            s.nud = function () {\n                return this;\n            };\n        };\n\n        // match infix operators\n        // <expression> <operator> <expression>\n        // left associative\n        var infix = function (id, bp, led) {\n            var bindingPower = bp || operators[id];\n            var s = symbol(id, bindingPower);\n            s.led = led || function (left) {\n                this.lhs = left;\n                this.rhs = expression(bindingPower);\n                this.type = \"binary\";\n                return this;\n            };\n            return s;\n        };\n\n        // match infix operators\n        // <expression> <operator> <expression>\n        // right associative\n        var infixr = function (id, bp, led) {\n            var s = symbol(id, bp);\n            s.led = led;\n            return s;\n        };\n\n        // match prefix operators\n        // <operator> <expression>\n        var prefix = function (id, nud) {\n            var s = symbol(id);\n            s.nud = nud || function () {\n                this.expression = expression(70);\n                this.type = \"unary\";\n                return this;\n            };\n            return s;\n        };\n\n        terminal(\"(end)\");\n        terminal(\"(name)\");\n        terminal(\"(literal)\");\n        terminal(\"(regex)\");\n        symbol(\":\");\n        symbol(\";\");\n        symbol(\",\");\n        symbol(\")\");\n        symbol(\"]\");\n        symbol(\"}\");\n        symbol(\"..\"); // range operator\n        infix(\".\"); // map operator\n        infix(\"+\"); // numeric addition\n        infix(\"-\"); // numeric subtraction\n        infix(\"*\"); // numeric multiplication\n        infix(\"/\"); // numeric division\n        infix(\"%\"); // numeric modulus\n        infix(\"=\"); // equality\n        infix(\"<\"); // less than\n        infix(\">\"); // greater than\n        infix(\"!=\"); // not equal to\n        infix(\"<=\"); // less than or equal\n        infix(\">=\"); // greater than or equal\n        infix(\"&\"); // string concatenation\n        infix(\"and\"); // Boolean AND\n        infix(\"or\"); // Boolean OR\n        infix(\"in\"); // is member of array\n        terminal(\"and\"); // the 'keywords' can also be used as terminals (field names)\n        terminal(\"or\"); //\n        terminal(\"in\"); //\n        prefix(\"-\"); // unary numeric negation\n        infix(\"~>\"); // function application\n\n        infixr(\"(error)\", 10, function (left) {\n            this.lhs = left;\n\n            this.error = node.error;\n            this.remaining = remainingTokens();\n            this.type = 'error';\n            return this;\n        });\n\n        // field wildcard (single level)\n        prefix('*', function () {\n            this.type = \"wildcard\";\n            return this;\n        });\n\n        // descendant wildcard (multi-level)\n        prefix('**', function () {\n            this.type = \"descendant\";\n            return this;\n        });\n\n        // parent operator\n        prefix('%', function () {\n            this.type = \"parent\";\n            return this;\n        });\n\n        // function invocation\n        infix(\"(\", operators['('], function (left) {\n            // left is is what we are trying to invoke\n            this.procedure = left;\n            this.type = 'function';\n            this.arguments = [];\n            if (node.id !== ')') {\n                for (; ;) {\n                    if (node.type === 'operator' && node.id === '?') {\n                        // partial function application\n                        this.type = 'partial';\n                        this.arguments.push(node);\n                        advance('?');\n                    } else {\n                        this.arguments.push(expression(0));\n                    }\n                    if (node.id !== ',') break;\n                    advance(',');\n                }\n            }\n            advance(\")\", true);\n            // if the name of the function is 'function' or λ, then this is function definition (lambda function)\n            if (left.type === 'name' && (left.value === 'function' || left.value === '\\u03BB')) {\n                // all of the args must be VARIABLE tokens\n                this.arguments.forEach(function (arg, index) {\n                    if (arg.type !== 'variable') {\n                        return handleError({\n                            code: \"S0208\",\n                            stack: (new Error()).stack,\n                            position: arg.position,\n                            token: arg.value,\n                            value: index + 1\n                        });\n                    }\n                });\n                this.type = 'lambda';\n                // is the next token a '<' - if so, parse the function signature\n                if (node.id === '<') {\n                    var sigPos = node.position;\n                    var depth = 1;\n                    var sig = '<';\n                    while (depth > 0 && node.id !== '{' && node.id !== '(end)') {\n                        var tok = advance();\n                        if (tok.id === '>') {\n                            depth--;\n                        } else if (tok.id === '<') {\n                            depth++;\n                        }\n                        sig += tok.value;\n                    }\n                    advance('>');\n                    try {\n                        this.signature = parseSignature(sig);\n                    } catch (err) {\n                        // insert the position into this error\n                        err.position = sigPos + err.offset;\n                        return handleError(err);\n                    }\n                }\n                // parse the function body\n                advance('{');\n                this.body = expression(0);\n                advance('}');\n            }\n            return this;\n        });\n\n        // parenthesis - block expression\n        prefix(\"(\", function () {\n            var expressions = [];\n            while (node.id !== \")\") {\n                expressions.push(expression(0));\n                if (node.id !== \";\") {\n                    break;\n                }\n                advance(\";\");\n            }\n            advance(\")\", true);\n            this.type = 'block';\n            this.expressions = expressions;\n            return this;\n        });\n\n        // array constructor\n        prefix(\"[\", function () {\n            var a = [];\n            if (node.id !== \"]\") {\n                for (; ;) {\n                    var item = expression(0);\n                    if (node.id === \"..\") {\n                        // range operator\n                        var range = {type: \"binary\", value: \"..\", position: node.position, lhs: item};\n                        advance(\"..\");\n                        range.rhs = expression(0);\n                        item = range;\n                    }\n                    a.push(item);\n                    if (node.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"]\", true);\n            this.expressions = a;\n            this.type = \"unary\";\n            return this;\n        });\n\n        // filter - predicate or array index\n        infix(\"[\", operators['['], function (left) {\n            if (node.id === \"]\") {\n                // empty predicate means maintain singleton arrays in the output\n                var step = left;\n                while (step && step.type === 'binary' && step.value === '[') {\n                    step = step.lhs;\n                }\n                step.keepArray = true;\n                advance(\"]\");\n                return left;\n            } else {\n                this.lhs = left;\n                this.rhs = expression(operators[']']);\n                this.type = 'binary';\n                advance(\"]\", true);\n                return this;\n            }\n        });\n\n        // order-by\n        infix(\"^\", operators['^'], function (left) {\n            advance(\"(\");\n            var terms = [];\n            for (; ;) {\n                var term = {\n                    descending: false\n                };\n                if (node.id === \"<\") {\n                    // ascending sort\n                    advance(\"<\");\n                } else if (node.id === \">\") {\n                    // descending sort\n                    term.descending = true;\n                    advance(\">\");\n                } else {\n                    //unspecified - default to ascending\n                }\n                term.expression = expression(0);\n                terms.push(term);\n                if (node.id !== \",\") {\n                    break;\n                }\n                advance(\",\");\n            }\n            advance(\")\");\n            this.lhs = left;\n            this.rhs = terms;\n            this.type = 'binary';\n            return this;\n        });\n\n        var objectParser = function (left) {\n            var a = [];\n            if (node.id !== \"}\") {\n                for (; ;) {\n                    var n = expression(0);\n                    advance(\":\");\n                    var v = expression(0);\n                    a.push([n, v]); // holds an array of name/value expression pairs\n                    if (node.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"}\", true);\n            if (typeof left === 'undefined') {\n                // NUD - unary prefix form\n                this.lhs = a;\n                this.type = \"unary\";\n            } else {\n                // LED - binary infix form\n                this.lhs = left;\n                this.rhs = a;\n                this.type = 'binary';\n            }\n            return this;\n        };\n\n        // object constructor\n        prefix(\"{\", objectParser);\n\n        // object grouping\n        infix(\"{\", operators['{'], objectParser);\n\n        // bind variable\n        infixr(\":=\", operators[':='], function (left) {\n            if (left.type !== 'variable') {\n                return handleError({\n                    code: \"S0212\",\n                    stack: (new Error()).stack,\n                    position: left.position,\n                    token: left.value\n                });\n            }\n            this.lhs = left;\n            this.rhs = expression(operators[':='] - 1); // subtract 1 from bindingPower for right associative operators\n            this.type = \"binary\";\n            return this;\n        });\n\n        // focus variable bind\n        infix(\"@\", operators['@'], function (left) {\n            this.lhs = left;\n            this.rhs = expression(operators['@']);\n            if(this.rhs.type !== 'variable') {\n                return handleError({\n                    code: \"S0214\",\n                    stack: (new Error()).stack,\n                    position: this.rhs.position,\n                    token: \"@\"\n                });\n            }\n            this.type = \"binary\";\n            return this;\n        });\n\n        // index (position) variable bind\n        infix(\"#\", operators['#'], function (left) {\n            this.lhs = left;\n            this.rhs = expression(operators['#']);\n            if(this.rhs.type !== 'variable') {\n                return handleError({\n                    code: \"S0214\",\n                    stack: (new Error()).stack,\n                    position: this.rhs.position,\n                    token: \"#\"\n                });\n            }\n            this.type = \"binary\";\n            return this;\n        });\n\n        // if/then/else ternary operator ?:\n        infix(\"?\", operators['?'], function (left) {\n            this.type = 'condition';\n            this.condition = left;\n            this.then = expression(0);\n            if (node.id === ':') {\n                // else condition\n                advance(\":\");\n                this.else = expression(0);\n            }\n            return this;\n        });\n\n        // object transformer\n        prefix(\"|\", function () {\n            this.type = 'transform';\n            this.pattern = expression(0);\n            advance('|');\n            this.update = expression(0);\n            if (node.id === ',') {\n                advance(',');\n                this.delete = expression(0);\n            }\n            advance('|');\n            return this;\n        });\n\n        // tail call optimization\n        // this is invoked by the post parser to analyse lambda functions to see\n        // if they make a tail call.  If so, it is replaced by a thunk which will\n        // be invoked by the trampoline loop during function application.\n        // This enables tail-recursive functions to be written without growing the stack\n        var tailCallOptimize = function (expr) {\n            var result;\n            if (expr.type === 'function' && !expr.predicate) {\n                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};\n                thunk.body = expr;\n                result = thunk;\n            } else if (expr.type === 'condition') {\n                // analyse both branches\n                expr.then = tailCallOptimize(expr.then);\n                if (typeof expr.else !== 'undefined') {\n                    expr.else = tailCallOptimize(expr.else);\n                }\n                result = expr;\n            } else if (expr.type === 'block') {\n                // only the last expression in the block\n                var length = expr.expressions.length;\n                if (length > 0) {\n                    expr.expressions[length - 1] = tailCallOptimize(expr.expressions[length - 1]);\n                }\n                result = expr;\n            } else {\n                result = expr;\n            }\n            return result;\n        };\n\n        var ancestorLabel = 0;\n        var ancestorIndex = 0;\n        var ancestry = [];\n\n        var seekParent = function (node, slot) {\n            switch (node.type) {\n                case 'name':\n                case 'wildcard':\n                    slot.level--;\n                    if(slot.level === 0) {\n                        if (typeof node.ancestor === 'undefined') {\n                            node.ancestor = slot;\n                        } else {\n                            // reuse the existing label\n                            ancestry[slot.index].slot.label = node.ancestor.label;\n                            node.ancestor = slot;\n                        }\n                        node.tuple = true;\n                    }\n                    break;\n                case 'parent':\n                    slot.level++;\n                    break;\n                case 'block':\n                    // look in last expression in the block\n                    if(node.expressions.length > 0) {\n                        node.tuple = true;\n                        slot = seekParent(node.expressions[node.expressions.length - 1], slot);\n                    }\n                    break;\n                case 'path':\n                    // last step in path\n                    node.tuple = true;\n                    var index = node.steps.length - 1;\n                    slot = seekParent(node.steps[index--], slot);\n                    while (slot.level > 0 && index >= 0) {\n                        // check previous steps\n                        slot = seekParent(node.steps[index--], slot);\n                    }\n                    break;\n                default:\n                    // error - can't derive ancestor\n                    throw {\n                        code: \"S0217\",\n                        token: node.type,\n                        position: node.position\n                    };\n            }\n            return slot;\n        };\n\n        var pushAncestry = function(result, value) {\n            if(typeof value.seekingParent !== 'undefined' || value.type === 'parent') {\n                var slots = (typeof value.seekingParent !== 'undefined') ? value.seekingParent : [];\n                if (value.type === 'parent') {\n                    slots.push(value.slot);\n                }\n                if(typeof result.seekingParent === 'undefined') {\n                    result.seekingParent = slots;\n                } else {\n                    Array.prototype.push.apply(result.seekingParent, slots);\n                }\n            }\n        };\n\n        var resolveAncestry = function(path) {\n            var index = path.steps.length - 1;\n            var laststep = path.steps[index];\n            var slots = (typeof laststep.seekingParent !== 'undefined') ? laststep.seekingParent : [];\n            if (laststep.type === 'parent') {\n                slots.push(laststep.slot);\n            }\n            for(var is = 0; is < slots.length; is++) {\n                var slot = slots[is];\n                index = path.steps.length - 2;\n                while (slot.level > 0) {\n                    if (index < 0) {\n                        if(typeof path.seekingParent === 'undefined') {\n                            path.seekingParent = [slot];\n                        } else {\n                            path.seekingParent.push(slot);\n                        }\n                        break;\n                    }\n                    // try previous step\n                    var step = path.steps[index--];\n                    // multiple contiguous steps that bind the focus should be skipped\n                    while(index >= 0 && step.focus && path.steps[index].focus) {\n                        step = path.steps[index--];\n                    }\n                    slot = seekParent(step, slot);\n                }\n            }\n        };\n\n        // post-parse stage\n        // the purpose of this is to add as much semantic value to the parse tree as possible\n        // in order to simplify the work of the evaluator.\n        // This includes flattening the parts of the AST representing location paths,\n        // converting them to arrays of steps which in turn may contain arrays of predicates.\n        // following this, nodes containing '.' and '[' should be eliminated from the AST.\n        var processAST = function (expr) {\n            var result;\n            switch (expr.type) {\n                case 'binary':\n                    switch (expr.value) {\n                        case '.':\n                            var lstep = processAST(expr.lhs);\n\n                            if (lstep.type === 'path') {\n                                result = lstep;\n                            } else {\n                                result = {type: 'path', steps: [lstep]};\n                            }\n                            if(lstep.type === 'parent') {\n                                result.seekingParent = [lstep.slot];\n                            }\n                            var rest = processAST(expr.rhs);\n                            if (rest.type === 'function' &&\n                                rest.procedure.type === 'path' &&\n                                rest.procedure.steps.length === 1 &&\n                                rest.procedure.steps[0].type === 'name' &&\n                                result.steps[result.steps.length - 1].type === 'function') {\n                                // next function in chain of functions - will override a thenable\n                                result.steps[result.steps.length - 1].nextFunction = rest.procedure.steps[0].value;\n                            }\n                            if (rest.type === 'path') {\n                                Array.prototype.push.apply(result.steps, rest.steps);\n                            } else {\n                                if(typeof rest.predicate !== 'undefined') {\n                                    rest.stages = rest.predicate;\n                                    delete rest.predicate;\n                                }\n                                result.steps.push(rest);\n                            }\n                            // any steps within a path that are string literals, should be changed to 'name'\n                            result.steps.filter(function (step) {\n                                if (step.type === 'number' || step.type === 'value') {\n                                    // don't allow steps to be numbers or the values true/false/null\n                                    throw {\n                                        code: \"S0213\",\n                                        stack: (new Error()).stack,\n                                        position: step.position,\n                                        value: step.value\n                                    };\n                                }\n                                return step.type === 'string';\n                            }).forEach(function (lit) {\n                                lit.type = 'name';\n                            });\n                            // any step that signals keeping a singleton array, should be flagged on the path\n                            if (result.steps.filter(function (step) {\n                                return step.keepArray === true;\n                            }).length > 0) {\n                                result.keepSingletonArray = true;\n                            }\n                            // if first step is a path constructor, flag it for special handling\n                            var firststep = result.steps[0];\n                            if (firststep.type === 'unary' && firststep.value === '[') {\n                                firststep.consarray = true;\n                            }\n                            // if the last step is an array constructor, flag it so it doesn't flatten\n                            var laststep = result.steps[result.steps.length - 1];\n                            if (laststep.type === 'unary' && laststep.value === '[') {\n                                laststep.consarray = true;\n                            }\n                            resolveAncestry(result);\n                            break;\n                        case '[':\n                            // predicated step\n                            // LHS is a step or a predicated step\n                            // RHS is the predicate expr\n                            result = processAST(expr.lhs);\n                            var step = result;\n                            var type = 'predicate';\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                                type = 'stages';\n                            }\n                            if (typeof step.group !== 'undefined') {\n                                throw {\n                                    code: \"S0209\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            if (typeof step[type] === 'undefined') {\n                                step[type] = [];\n                            }\n                            var predicate = processAST(expr.rhs);\n                            if(typeof predicate.seekingParent !== 'undefined') {\n                                predicate.seekingParent.forEach(slot => {\n                                    if(slot.level === 1) {\n                                        seekParent(step, slot);\n                                    } else {\n                                        slot.level--;\n                                    }\n                                });\n                                pushAncestry(step, predicate);\n                            }\n                            step[type].push({type: 'filter', expr: predicate, position: expr.position});\n                            break;\n                        case '{':\n                            // group-by\n                            // LHS is a step or a predicated step\n                            // RHS is the object constructor expr\n                            result = processAST(expr.lhs);\n                            if (typeof result.group !== 'undefined') {\n                                throw {\n                                    code: \"S0210\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            // object constructor - process each pair\n                            result.group = {\n                                lhs: expr.rhs.map(function (pair) {\n                                    return [processAST(pair[0]), processAST(pair[1])];\n                                }),\n                                position: expr.position\n                            };\n                            break;\n                        case '^':\n                            // order-by\n                            // LHS is the array to be ordered\n                            // RHS defines the terms\n                            result = processAST(expr.lhs);\n                            if (result.type !== 'path') {\n                                result = {type: 'path', steps: [result]};\n                            }\n                            var sortStep = {type: 'sort', position: expr.position};\n                            sortStep.terms = expr.rhs.map(function (terms) {\n                                var expression = processAST(terms.expression);\n                                pushAncestry(sortStep, expression);\n                                return {\n                                    descending: terms.descending,\n                                    expression: expression\n                                };\n                            });\n                            result.steps.push(sortStep);\n                            resolveAncestry(result);\n                            break;\n                        case ':=':\n                            result = {type: 'bind', value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            pushAncestry(result, result.rhs);\n                            break;\n                        case '@':\n                            result = processAST(expr.lhs);\n                            step = result;\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                            }\n                            // throw error if there are any predicates defined at this point\n                            // at this point the only type of stages can be predicates\n                            if(typeof step.stages !== 'undefined' || typeof step.predicate !== 'undefined') {\n                                throw {\n                                    code: \"S0215\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            // also throw if this is applied after an 'order-by' clause\n                            if(step.type === 'sort') {\n                                throw {\n                                    code: \"S0216\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            if(expr.keepArray) {\n                                step.keepArray = true;\n                            }\n                            step.focus = expr.rhs.value;\n                            step.tuple = true;\n                            break;\n                        case '#':\n                            result = processAST(expr.lhs);\n                            step = result;\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                            } else {\n                                result = {type: 'path', steps: [result]};\n                                if (typeof step.predicate !== 'undefined') {\n                                    step.stages = step.predicate;\n                                    delete step.predicate;\n                                }\n                            }\n                            if (typeof step.stages === 'undefined') {\n                                step.index = expr.rhs.value;\n                            } else {\n                                step.stages.push({type: 'index', value: expr.rhs.value, position: expr.position});\n                            }\n                            step.tuple = true;\n                            break;\n                        case '~>':\n                            result = {type: 'apply', value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            result.keepArray = result.lhs.keepArray || result.rhs.keepArray;\n                            break;\n                        default:\n                            result = {type: expr.type, value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            pushAncestry(result, result.lhs);\n                            pushAncestry(result, result.rhs);\n                    }\n                    break;\n                case 'unary':\n                    result = {type: expr.type, value: expr.value, position: expr.position};\n                    if (expr.value === '[') {\n                        // array constructor - process each item\n                        result.expressions = expr.expressions.map(function (item) {\n                            var value = processAST(item);\n                            pushAncestry(result, value);\n                            return value;\n                        });\n                    } else if (expr.value === '{') {\n                        // object constructor - process each pair\n                        result.lhs = expr.lhs.map(function (pair) {\n                            var key = processAST(pair[0]);\n                            pushAncestry(result, key);\n                            var value = processAST(pair[1]);\n                            pushAncestry(result, value);\n                            return [key, value];\n                        });\n                    } else {\n                        // all other unary expressions - just process the expression\n                        result.expression = processAST(expr.expression);\n                        // if unary minus on a number, then pre-process\n                        if (expr.value === '-' && result.expression.type === 'number') {\n                            result = result.expression;\n                            result.value = -result.value;\n                        } else {\n                            pushAncestry(result, result.expression);\n                        }\n                    }\n                    break;\n                case 'function':\n                case 'partial':\n                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};\n                    result.arguments = expr.arguments.map(function (arg) {\n                        var argAST = processAST(arg);\n                        pushAncestry(result, argAST);\n                        return argAST;\n                    });\n                    result.procedure = processAST(expr.procedure);\n                    break;\n                case 'lambda':\n                    result = {\n                        type: expr.type,\n                        arguments: expr.arguments,\n                        signature: expr.signature,\n                        position: expr.position\n                    };\n                    var body = processAST(expr.body);\n                    result.body = tailCallOptimize(body);\n                    break;\n                case 'condition':\n                    result = {type: expr.type, position: expr.position};\n                    result.condition = processAST(expr.condition);\n                    pushAncestry(result, result.condition);\n                    result.then = processAST(expr.then);\n                    pushAncestry(result, result.then);\n                    if (typeof expr.else !== 'undefined') {\n                        result.else = processAST(expr.else);\n                        pushAncestry(result, result.else);\n                    }\n                    break;\n                case 'transform':\n                    result = {type: expr.type, position: expr.position};\n                    result.pattern = processAST(expr.pattern);\n                    result.update = processAST(expr.update);\n                    if (typeof expr.delete !== 'undefined') {\n                        result.delete = processAST(expr.delete);\n                    }\n                    break;\n                case 'block':\n                    result = {type: expr.type, position: expr.position};\n                    // array of expressions - process each one\n                    result.expressions = expr.expressions.map(function (item) {\n                        var part = processAST(item);\n                        pushAncestry(result, part);\n                        if (part.consarray || (part.type === 'path' && part.steps[0].consarray)) {\n                            result.consarray = true;\n                        }\n                        return part;\n                    });\n                    // TODO scan the array of expressions to see if any of them assign variables\n                    // if so, need to mark the block as one that needs to create a new frame\n                    break;\n                case 'name':\n                    result = {type: 'path', steps: [expr]};\n                    if (expr.keepArray) {\n                        result.keepSingletonArray = true;\n                    }\n                    break;\n                case 'parent':\n                    result = {type: 'parent', slot: { label: '!' + ancestorLabel++, level: 1, index: ancestorIndex++ } };\n                    ancestry.push(result);\n                    break;\n                case 'string':\n                case 'number':\n                case 'value':\n                case 'wildcard':\n                case 'descendant':\n                case 'variable':\n                case 'regex':\n                    result = expr;\n                    break;\n                case 'operator':\n                    // the tokens 'and' and 'or' might have been used as a name rather than an operator\n                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {\n                        expr.type = 'name';\n                        result = processAST(expr);\n                    } else /* istanbul ignore else */ if (expr.value === '?') {\n                        // partial application\n                        result = expr;\n                    } else {\n                        throw {\n                            code: \"S0201\",\n                            stack: (new Error()).stack,\n                            position: expr.position,\n                            token: expr.value\n                        };\n                    }\n                    break;\n                case 'error':\n                    result = expr;\n                    if (expr.lhs) {\n                        result = processAST(expr.lhs);\n                    }\n                    break;\n                default:\n                    var code = \"S0206\";\n                    /* istanbul ignore else */\n                    if (expr.id === '(end)') {\n                        code = \"S0207\";\n                    }\n                    var err = {\n                        code: code,\n                        position: expr.position,\n                        token: expr.value\n                    };\n                    if (recover) {\n                        errors.push(err);\n                        return {type: 'error', error: err};\n                    } else {\n                        err.stack = (new Error()).stack;\n                        throw err;\n                    }\n            }\n            if (expr.keepArray) {\n                result.keepArray = true;\n            }\n            return result;\n        };\n\n        // now invoke the tokenizer and the parser and return the syntax tree\n        lexer = tokenizer(source);\n        advance();\n        // parse the tokens\n        var expr = expression(0);\n        if (node.id !== '(end)') {\n            var err = {\n                code: \"S0201\",\n                position: node.position,\n                token: node.value\n            };\n            handleError(err);\n        }\n        expr = processAST(expr);\n\n        if(expr.type === 'parent' || typeof expr.seekingParent !== 'undefined') {\n            // error - trying to derive ancestor at top level\n            throw {\n                code: \"S0217\",\n                token: expr.type,\n                position: expr.position\n            };\n        }\n\n        if (errors.length > 0) {\n            expr.errors = errors;\n        }\n\n        return expr;\n    };\n\n    return parser;\n})();\n\nmodule.exports = parser;\n\n},{\"./signature\":5}],5:[function(require,module,exports){\n/**\n * © Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar utils = require('./utils');\n\nconst signature = (() => {\n    'use strict';\n\n    // A mapping between the function signature symbols and the full plural of the type\n    // Expected to be used in error messages\n    var arraySignatureMapping = {\n        \"a\": \"arrays\",\n        \"b\": \"booleans\",\n        \"f\": \"functions\",\n        \"n\": \"numbers\",\n        \"o\": \"objects\",\n        \"s\": \"strings\"\n    };\n\n    /**\n     * Parses a function signature definition and returns a validation function\n     * @param {string} signature - the signature between the <angle brackets>\n     * @returns {Function} validation function\n     */\n    function parseSignature(signature) {\n        // create a Regex that represents this signature and return a function that when invoked,\n        // returns the validated (possibly fixed-up) arguments, or throws a validation error\n        // step through the signature, one symbol at a time\n        var position = 1;\n        var params = [];\n        var param = {};\n        var prevParam = param;\n        while (position < signature.length) {\n            var symbol = signature.charAt(position);\n            if (symbol === ':') {\n                // TODO figure out what to do with the return type\n                // ignore it for now\n                break;\n            }\n\n            var next = function () {\n                params.push(param);\n                prevParam = param;\n                param = {};\n            };\n\n            var findClosingBracket = function (str, start, openSymbol, closeSymbol) {\n                // returns the position of the closing symbol (e.g. bracket) in a string\n                // that balances the opening symbol at position start\n                var depth = 1;\n                var position = start;\n                while (position < str.length) {\n                    position++;\n                    symbol = str.charAt(position);\n                    if (symbol === closeSymbol) {\n                        depth--;\n                        if (depth === 0) {\n                            // we're done\n                            break; // out of while loop\n                        }\n                    } else if (symbol === openSymbol) {\n                        depth++;\n                    }\n                }\n                return position;\n            };\n\n            switch (symbol) {\n                case 's': // string\n                case 'n': // number\n                case 'b': // boolean\n                case 'l': // not so sure about expecting null?\n                case 'o': // object\n                    param.regex = '[' + symbol + 'm]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'a': // array\n                    //  normally treat any value as singleton array\n                    param.regex = '[asnblfom]';\n                    param.type = symbol;\n                    param.array = true;\n                    next();\n                    break;\n                case 'f': // function\n                    param.regex = 'f';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'j': // any JSON type\n                    param.regex = '[asnblom]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'x': // any type\n                    param.regex = '[asnblfom]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case '-': // use context if param not supplied\n                    prevParam.context = true;\n                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime\n                    prevParam.regex += '?';\n                    break;\n                case '?': // optional param\n                case '+': // one or more\n                    prevParam.regex += symbol;\n                    break;\n                case '(': // choice of types\n                    // search forward for matching ')'\n                    var endParen = findClosingBracket(signature, position, '(', ')');\n                    var choice = signature.substring(position + 1, endParen);\n                    if (choice.indexOf('<') === -1) {\n                        // no parameterized types, simple regex\n                        param.regex = '[' + choice + 'm]';\n                    } else {\n                        // TODO harder\n                        throw {\n                            code: \"S0402\",\n                            stack: (new Error()).stack,\n                            value: choice,\n                            offset: position\n                        };\n                    }\n                    param.type = '(' + choice + ')';\n                    position = endParen;\n                    next();\n                    break;\n                case '<': // type parameter - can only be applied to 'a' and 'f'\n                    if (prevParam.type === 'a' || prevParam.type === 'f') {\n                        // search forward for matching '>'\n                        var endPos = findClosingBracket(signature, position, '<', '>');\n                        prevParam.subtype = signature.substring(position + 1, endPos);\n                        position = endPos;\n                    } else {\n                        throw {\n                            code: \"S0401\",\n                            stack: (new Error()).stack,\n                            value: prevParam.type,\n                            offset: position\n                        };\n                    }\n                    break;\n            }\n            position++;\n        }\n        var regexStr = '^' +\n            params.map(function (param) {\n                return '(' + param.regex + ')';\n            }).join('') +\n            '$';\n        var regex = new RegExp(regexStr);\n        var getSymbol = function (value) {\n            var symbol;\n            if (utils.isFunction(value)) {\n                symbol = 'f';\n            } else {\n                var type = typeof value;\n                switch (type) {\n                    case 'string':\n                        symbol = 's';\n                        break;\n                    case 'number':\n                        symbol = 'n';\n                        break;\n                    case 'boolean':\n                        symbol = 'b';\n                        break;\n                    case 'object':\n                        if (value === null) {\n                            symbol = 'l';\n                        } else if (Array.isArray(value)) {\n                            symbol = 'a';\n                        } else {\n                            symbol = 'o';\n                        }\n                        break;\n                    case 'undefined':\n                    default:\n                        // any value can be undefined, but should be allowed to match\n                        symbol = 'm'; // m for missing\n                }\n            }\n            return symbol;\n        };\n\n        var throwValidationError = function (badArgs, badSig) {\n            // to figure out where this went wrong we need apply each component of the\n            // regex to each argument until we get to the one that fails to match\n            var partialPattern = '^';\n            var goodTo = 0;\n            for (var index = 0; index < params.length; index++) {\n                partialPattern += params[index].regex;\n                var match = badSig.match(partialPattern);\n                if (match === null) {\n                    // failed here\n                    throw {\n                        code: \"T0410\",\n                        stack: (new Error()).stack,\n                        value: badArgs[goodTo],\n                        index: goodTo + 1\n                    };\n                }\n                goodTo = match[0].length;\n            }\n            // if it got this far, it's probably because of extraneous arguments (we\n            // haven't added the trailing '$' in the regex yet.\n            throw {\n                code: \"T0410\",\n                stack: (new Error()).stack,\n                value: badArgs[goodTo],\n                index: goodTo + 1\n            };\n        };\n\n        return {\n            definition: signature,\n            validate: function (args, context) {\n                var suppliedSig = '';\n                args.forEach(function (arg) {\n                    suppliedSig += getSymbol(arg);\n                });\n                var isValid = regex.exec(suppliedSig);\n                if (isValid) {\n                    var validatedArgs = [];\n                    var argIndex = 0;\n                    params.forEach(function (param, index) {\n                        var arg = args[argIndex];\n                        var match = isValid[index + 1];\n                        if (match === '') {\n                            if (param.context && param.contextRegex) {\n                                // substitute context value for missing arg\n                                // first check that the context value is the right type\n                                var contextType = getSymbol(context);\n                                // test contextType against the regex for this arg (without the trailing ?)\n                                if (param.contextRegex.test(contextType)) {\n                                    validatedArgs.push(context);\n                                } else {\n                                    // context value not compatible with this argument\n                                    throw {\n                                        code: \"T0411\",\n                                        stack: (new Error()).stack,\n                                        value: context,\n                                        index: argIndex + 1\n                                    };\n                                }\n                            } else {\n                                validatedArgs.push(arg);\n                                argIndex++;\n                            }\n                        } else {\n                            // may have matched multiple args (if the regex ends with a '+'\n                            // split into single tokens\n                            match.split('').forEach(function (single) {\n                                if (param.type === 'a') {\n                                    if (single === 'm') {\n                                        // missing (undefined)\n                                        arg = undefined;\n                                    } else {\n                                        arg = args[argIndex];\n                                        var arrayOK = true;\n                                        // is there type information on the contents of the array?\n                                        if (typeof param.subtype !== 'undefined') {\n                                            if (single !== 'a' && match !== param.subtype) {\n                                                arrayOK = false;\n                                            } else if (single === 'a') {\n                                                if (arg.length > 0) {\n                                                    var itemType = getSymbol(arg[0]);\n                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further\n                                                        arrayOK = false;\n                                                    } else {\n                                                        // make sure every item in the array is this type\n                                                        var differentItems = arg.filter(function (val) {\n                                                            return (getSymbol(val) !== itemType);\n                                                        });\n                                                        arrayOK = (differentItems.length === 0);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if (!arrayOK) {\n                                            throw {\n                                                code: \"T0412\",\n                                                stack: (new Error()).stack,\n                                                value: arg,\n                                                index: argIndex + 1,\n                                                type: arraySignatureMapping[param.subtype]\n                                            };\n                                        }\n                                        // the function expects an array. If it's not one, make it so\n                                        if (single !== 'a') {\n                                            arg = [arg];\n                                        }\n                                    }\n                                    validatedArgs.push(arg);\n                                    argIndex++;\n                                } else {\n                                    validatedArgs.push(arg);\n                                    argIndex++;\n                                }\n                            });\n                        }\n                    });\n                    return validatedArgs;\n                }\n                throwValidationError(args, suppliedSig);\n            }\n        };\n    }\n\n    return parseSignature;\n})();\n\nmodule.exports = signature;\n\n},{\"./utils\":6}],6:[function(require,module,exports){\n/**\n * © Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nconst utils = (() => {\n    'use strict';\n\n    /**\n     * Check if value is a finite number\n     * @param {float} n - number to evaluate\n     * @returns {boolean} True if n is a finite number\n     */\n    function isNumeric(n) {\n        var isNum = false;\n        if(typeof n === 'number') {\n            isNum = !isNaN(n);\n            if (isNum && !isFinite(n)) {\n                throw {\n                    code: \"D1001\",\n                    value: n,\n                    stack: (new Error()).stack\n                };\n            }\n        }\n        return isNum;\n    }\n\n    /**\n     * Returns true if the arg is an array of strings\n     * @param {*} arg - the item to test\n     * @returns {boolean} True if arg is an array of strings\n     */\n    function isArrayOfStrings(arg) {\n        var result = false;\n        /* istanbul ignore else */\n        if(Array.isArray(arg)) {\n            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);\n        }\n        return result;\n    }\n\n    /**\n     * Returns true if the arg is an array of numbers\n     * @param {*} arg - the item to test\n     * @returns {boolean} True if arg is an array of numbers\n     */\n    function isArrayOfNumbers(arg) {\n        var result = false;\n        if(Array.isArray(arg)) {\n            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);\n        }\n        return result;\n    }\n\n    /**\n     * Create an empty sequence to contain query results\n     * @returns {Array} - empty sequence\n     */\n    function createSequence() {\n        var sequence = [];\n        sequence.sequence = true;\n        if (arguments.length === 1) {\n            sequence.push(arguments[0]);\n        }\n        return sequence;\n    }\n\n    /**\n     * Tests if a value is a sequence\n     * @param {*} value the value to test\n     * @returns {boolean} true if it's a sequence\n     */\n    function isSequence(value) {\n        return value.sequence === true && Array.isArray(value);\n    }\n\n    /**\n     *\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is a function (lambda or built-in)\n     */\n    function isFunction(arg) {\n        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');\n    }\n\n    /**\n     * Returns the arity (number of arguments) of the function\n     * @param {*} func - the function\n     * @returns {*} - the arity\n     */\n    function getFunctionArity(func) {\n        var arity = typeof func.arity === 'number' ? func.arity :\n            typeof func.implementation === 'function' ? func.implementation.length :\n                typeof func.length === 'number' ? func.length : func.arguments.length;\n        return arity;\n    }\n\n    /**\n     * Tests whether arg is a lambda function\n     * @param {*} arg - the value to test\n     * @returns {boolean} - true if it is a lambda function\n     */\n    function isLambda(arg) {\n        return arg && arg._jsonata_lambda === true;\n    }\n\n    // istanbul ignore next\n    var iteratorSymbol = (typeof Symbol === \"function\" ? Symbol : {}).iterator || \"@@iterator\";\n\n    /**\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is iterable\n     */\n    function isIterable(arg) {\n        return (\n            typeof arg === 'object' &&\n            arg !== null &&\n            iteratorSymbol in arg &&\n            'next' in arg &&\n            typeof arg.next === 'function'\n        );\n    }\n\n    /**\n     * Compares two values for equality\n     * @param {*} lhs first value\n     * @param {*} rhs second value\n     * @returns {boolean} true if they are deep equal\n     */\n    function isDeepEqual(lhs, rhs) {\n        if (lhs === rhs) {\n            return true;\n        }\n        if(typeof lhs === 'object' && typeof rhs === 'object' && lhs !== null && rhs !== null) {\n            if(Array.isArray(lhs) && Array.isArray(rhs)) {\n                // both arrays (or sequences)\n                // must be the same length\n                if(lhs.length !== rhs.length) {\n                    return false;\n                }\n                // must contain same values in same order\n                for(var ii = 0; ii < lhs.length; ii++) {\n                    if(!isDeepEqual(lhs[ii], rhs[ii])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            // both objects\n            // must have the same set of keys (in any order)\n            var lkeys = Object.getOwnPropertyNames(lhs);\n            var rkeys = Object.getOwnPropertyNames(rhs);\n            if(lkeys.length !== rkeys.length) {\n                return false;\n            }\n            lkeys = lkeys.sort();\n            rkeys = rkeys.sort();\n            for(ii=0; ii < lkeys.length; ii++) {\n                if(lkeys[ii] !== rkeys[ii]) {\n                    return false;\n                }\n            }\n            // must have the same values\n            for(ii=0; ii < lkeys.length; ii++) {\n                var key = lkeys[ii];\n                if(!isDeepEqual(lhs[key], rhs[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is a promise\n     */\n    function isPromise(arg) {\n        return (\n            typeof arg === 'object' &&\n                arg !== null &&\n                'then' in arg &&\n                typeof arg.then === 'function'\n        );\n    }\n\n    /**\n     * converts a string to an array of characters\n     * @param {string} str - the input string\n     * @returns {Array} - the array of characters\n     */\n    function stringToArray(str) {\n        var arr = [];\n        for (let char of str) {\n            arr.push(char);\n        }\n        return arr;\n    }\n\n    return {\n        isNumeric,\n        isArrayOfStrings,\n        isArrayOfNumbers,\n        createSequence,\n        isSequence,\n        isFunction,\n        isLambda,\n        isIterable,\n        getFunctionArity,\n        isDeepEqual,\n        stringToArray,\n        isPromise\n    };\n})();\n\nmodule.exports = utils;\n\n},{}]},{},[3])(3)\n});\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}